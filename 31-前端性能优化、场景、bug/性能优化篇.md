## scirpt标签放在header里面和放在body底部里面有什么区别？







## 前端项目部署后刷新页面会出现404的问题

>   注意！！！
>
>   ​     这个问题经常发生在我们使用Vue、React编写的单页面应用中，并且由于使用的路由模式是history模式导致的

前端项目部署后刷新页面出现 404 的问题，通常与 **前端路由模式** 和 **服务器配置** 有关

**根本原因**

-   **前端路由模式**：现代前端框架（如 Vue/React/Angular）通常使用两种路由模式：
    -   **Hash 模式**：URL 中包含 `#`（如 `https://example.com/#/home`），刷新时不会向服务器发送 `#` 后的路径。
    -   **History 模式**：使用 HTML5 History API（如 `https://example.com/home`），刷新时会向服务器请求 `/home` 路径，但服务器可能没有该路径的资源。
-   **服务器配置问题**：如果使用 History 模式，服务器未正确配置将所有请求重定向到入口文件（如 `index.html`），会导致 404。

>   hash模式通过监听浏览器的onhashchange()事件变化，查找对应的路由规则；
>
>   history模式是利用h5的history中新增的两个API pushState() 和 replaceState() 和一个事件onpopstate监听其URL变化；
>
>   hash模式能兼容到IE8，history模式 只能兼容到 IE10；
>
>   由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件（hashchange只能改变 # 后面的url片段）；
>
>   虽然hash路径出现在URL中，但是不会出现在HTTP请求中，对服务器完全没有影响，因此改变hash值不会重新加载页面，基本都是使用 hash 来实现前端路由的。
>
>   **重点：**
>
>   ​	hash模式在每次刷新页面时是直接更改“#”后的路径，history模式每次刷新会重新像服务器重新请求资源，但是服务器会把vue、react的路由地址当成文件路径访问（如: /pages/index），服务器又没有这个文件路径，且服务端没有配置相应的路由重定向，就会访问404；
>
>   ​	history模式的好处是可以进行修改历史记录，并且不会立刻像后端发起请求。不过如果对于项目没有硬性标准要求，我们可以直接使用hash模式开发。



**解决方案**

需配置服务器将所有非静态资源请求指向 `index.html`，由前端路由处理路径。

**Nginx 服务器**

修改 Nginx 配置文件（如 `nginx.conf` 或站点配置文件）：

```shell
server {
  listen 80;
  server_name example.com;
  root /path/to/your/project/dist;

  location / {
    try_files $uri $uri/ /index.html; # 关键配置
  }

  # 省略1w行
}
```

修改完配置文件，记得重新加载！！！



 **Apache 服务器**

在项目根目录或虚拟主机配置中添加 `.htaccess` 文件：

```xml
<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
</IfModule>
```



 **其他注意事项**

1.  **前端路由配置**：
    -   Vue Router 需设置 `mode: 'history'`。
    -   React Router 使用 `<BrowserRouter>`。
2.  **静态资源路径**：
    -   确保项目构建时配置了正确的 `publicPath`（如 `./` 相对路径）。
3.  **CDN/缓存问题**：
    -   清除 CDN 或浏览器缓存，避免旧配置残留。



## 当项目部署到服务器子文件路径时资源404问题

当项目部署到服务器的子文件路径（如 `/sub-path/`）时，出现资源 404 问题，通常是因为 **前端静态资源路径未正确配置** 或 **服务器未正确处理子路径请求**。



**核心原因**

-   **前端静态资源路径错误**：构建时未指定子路径作为基础路径（如 `publicPath` 或 `base`），导致资源引用路径错误（如 `/static/js/app.js` 而非 `/sub-path/static/js/app.js`）。
-   **服务器未配置子路径路由**：服务器未将子路径请求正确映射到前端入口文件（如 `index.html`）。
-   **前端路由未适配子路径**：前端路由未配置 `base` 路径，导致路由跳转错误



如比，我们将项目部署到了h5文件夹中，这时候的访问路径应该是http://127.0.0.1:8080/h5/，访问后会出现js和css资源404，因为配置默认是指向到绝对路径'/',也就是根目录，但是根目录没有这些资源文件，就会让项目访问失败。

**vue2.0**

```js
// vue.config.js
module.exports = {
    publicPath: '/h5/',
    ...
}
```

```js
// router
const createRouter = () => new Router({
  mode: 'history',
  base: '/h5',
  ...
})
```

**vue3.0**

```js
// vite.config.ts
export default defineConfig({
    base:'/h5/', // 替换为你的子路径
    ...
})
```

```js
// router
const router = createRouter({
    history: createWebHistory('/h5'),
    routes: []
});
```

**React **

```js
// package.json
{
  "homepage": "/h5",  // 替换为你的子路径
  "scripts": {
    "build": "react-scripts build"
  }
}
```

## 如何禁止别人调式前端页面代码

> 参考：https://juejin.cn/post/7262175454714626108?searchId=202504181531366D88A76DB15E3E135EA5#heading-6


在前端开发中，我们无法完全阻止别人调试前端页面代码，但可以通过一些技术手段和安全策略来增加调试难度。

以下是常见的实现方案：
- 无限 debugger
- 禁用右键：利用js禁用右键，可以减少用户通过右键菜单进行检查和调试的机会
- 禁用 F12 和开发者工具：利用js禁用F12键以及其他可以打开开发者工具的快捷键（如Ctrl+Shift+I），从而阻止用户使用开发者工具
- 代码混淆和压缩：如通过webpack等打包工具对代码进行混淆和压缩，使代码变得难以理解
- 检测开关开发者工具：利用js定期检测是否打开了开发者工具，如果打开了则重载页面，从而阻止用户使用开发者工具
    - 如： 窗口尺寸监听，打开了开发者工具，窗口尺寸会改变



**无限 debugger**

```javascript
// 基础版：每50ms触发一次断点
setInterval(() => { debugger }, 50);

// 增强版：动态生成不可格式化代码
new Function('while(1) debugger')();

// 终极版：加密混淆后的检测
const antiDebug = Function('return ' + '(!window.devtools ? ' +
  '(window.devtools = {}) : ' +
  '(window.location.reload(), false)')();
antiDebug();
```

**禁用右键**

比如说利用js禁用右键点击事件
```javascript
document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
})
```
不过这种方式只能应对小白，但凡有点经验的人都可以绕过这种方式


**禁用 F12 和开发者工具**

可以利用js捕获F12或其他快捷键的按键事件来组织它们被使用
```javascript
document.onKeydown = function (e) {
    if (e.keyCode === 123 ) { // F12
        return false;
    }
    if (e.ctrlKey && e.shiftKey && e.keyCode === 'I'.charCodeAt(0)) { // Ctrl + Shift + I
        return false;
    }
    if (e.ctrlKey && e.shiftKey && e.keyCode === 'C'.charCodeAt(0)) { // Ctrl + Shift + C
        return false;
    }
    if (e.ctrlKey && e.shiftKey && e.keyCode === 'J'.charCodeAt(0)) { // Ctrl + Shift + J
        return false;
    }
    if (e.ctrlKey && e.keyCode === 'U'.charCodeAt(0)) { // Ctrl + U
        return false;
    }
}
```
这种方式也只能阻止一些初级开发者


**代码混淆、加密、压缩**

例如使用Webpack、UglifyJS等工具，对js代码进行混淆、加密、压缩。

混淆

```
# 使用UglifyJS进行高级混淆
uglify-js src/app.js -o dist/app.min.js \
  --mangle --compress \
  --toplevel --mangle-props \
  --name-cache --source-map
```
混淆后，一般变量名、函数名都会被替换成无意义的短字符串，从而增加理解代码的难度

字符串加密
```javascript
// 原始代码
console.log('Hello World');

// 加密后
const _0x1234 = String.fromCharCode;
const _0x5678 = [_0x1234(72, 101, 108, 108, 111), _0x1234(32, 87, 111, 114, 108, 100)];
console[_0x1234(108, 111, 103)](_0x5678.join(''));
```

压缩
```javascript
// 原始代码
function hello() {
    console.log('Hello World');
}

// 压缩后
function hello() {console.log('Hello World')}
```
这个压缩的例子可能不是很明显，但是真是项目中的代码不可能这么简单，压缩后就很难阅读了



**窗口尺寸监听**
可以通过定期检测窗口尺寸的变化，如果窗口尺寸变化幅度过大，则认为用户打开了开发者工具，从而 reload 页面。
```javascript
setInterval(() => {
 if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
    alert('检测到开发者工具打开');
    window.location.reload(); 
  }
}, 500);
```

**console 对象劫持检测**
```javascript
const originalConsole = window.console;
const antiConsole = new Proxy(originalConsole, {
  get(target, key) {
    if (['log', 'warn', 'error'].includes(key)) {
      // 检测到控制台输出，可能正在调试
      window.location.href = 'https://example.com/blocked';
    }
    return target[key];
  }
});
window.console = antiConsole;
```



**动态代码注入**
```javascript
// 按需加载关键模块
const loadModule = async (moduleName) => {
  const script = document.createElement('script');
  script.src = `https://cdn.example.com/modules/${moduleName}.js?${Date.now()}`;
  script.onload = () => {
    window[moduleName](); // 执行动态注入的代码
  };
  document.head.appendChild(script);
};

// 使用时动态加载
loadModule('paymentProcessor');
```

**安全提示**
尽管在前端开发中，我们可以通过一些技术手段来阻止别人调试前端页面代码，但客户端代码始终是运行在用户的浏览器中，因此无法完全避免被调试和查看。
对于真正关键的逻辑和数据，应该尽量在后端实现，并通过确保API安全调用等措施确保安全