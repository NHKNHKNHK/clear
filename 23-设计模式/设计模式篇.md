## 单例模式中的双重检查锁为什么要检查两次？

在单例模式中使用双重检查锁（Double-Checked Locking）的**主要目的是为了提高多线程环境下的性能，同时确保线程安全**。以下是为什么要进行两次检查的原因：

**减少锁的开销**：

-   第一次检查：在进入同步块之前，先检查实例是否已经被创建。如果已经创建，则直接返回实例，避免进入同步块，从而减少锁的开销

**确保线程安全**：

-   第二次检查：即使有多个线程同时到达第一次检查的位置，只有一个线程能够进入同步块。进入同步块后，再次检查实例是否为`null`，以确保在多线程环境下实例只被创建一次。

示例：

```java
public class DclSingleton {
    // todo 创建对象，不是原子性操作，即使使用了双重检查锁，也可能在创建过程中产生半初始状态
    // volatile如果不加可能会出现半初始化的对象
    // 现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）,为了兼容性我们加上
    private volatile static DclSingleton INSTANCE;

    private DclSingleton() {
    }

    public static DclSingleton getInstance() {
        if (null == INSTANCE) {
            synchronized (DclSingleton.class) {
                if (null == INSTANCE) {
                    INSTANCE = new DclSingleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

在这种实现方式中，只要 INSTANCE被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。



**如下是单个检查实现的单例模式**

```java
public class LazySingleton3 {
    private static LazySingleton3 INSTANCE;

    private LazySingleton3() {
    }

    public static LazySingleton3 getINSTANCE() {  
        // todo 并未解决线程安全
        if (null == INSTANCE) {  
            synchronized (LazySingleton3.class){
                INSTANCE = new LazySingleton3(); // 同步代码块
            }
        }
        return INSTANCE;
    }
}
```

但是**这种同步方式并不能起到线程同步的作用**。如果一个线程进入 if (null == INSTANCE) 判断语句块，还为来得及往下执行，另一个线程也通过了这个判断语句，他同样回去创建一个实例，这时就产生了多个实例。

因此，双重检查极大避免了重复创建实例的可能。