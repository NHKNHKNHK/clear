## TCP/IP四层模型？



## OSI七层模型？







## IP



## HTTP



## DNS



## CDN



## TCP



## UDP



## ICMP



## ARP与RARP，有什么区别？





## Http和Https的区别？





## Http1.0和2.0的区别？



## Http2.0和3.0的区别？



## 到底什么是TCP？



## TCP用来解决什么？



## TCP与UDP的区别？



## 为什么要TCP？IP层实现控制不行吗？



## TCP的粘包和拆包？



## TCP三次握手？四次挥手？为什么要四次挥手？挥手一定要四次吗？



## 为什么要有TIME_WAIT?



## 等待2MSL会产生什么问题？如何解决？



## 超时重传机制是为了解决什么问题？



## 为什么还需要快速重传机制？





## TCP初始序列号ISN怎么取值？



## SYN超时怎么处理？



## SACK引入是为了解决什么问题？



## D-SACK又是什么？



## 滑动窗口的作用？



## 有了滑动窗口，为什么还需要拥塞控制？



## 拥塞控制步骤？



## 拥塞控制有哪些算法？



## 什么是WebSocket？

WebSocket 是基于 TCP 的一种新的**网络通信协议**。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建**持久性**的连接， 并进行**双向**数据传输。

与HTTP请求-响应模式不同，WebSocket允许浏览器和服务器直接进行**实时的、低延迟**的互动。这对于实时消息、在线游戏、股票行情等需要频繁更新的应用场景特别有用。



**WebScoket的优势**

-   **低延迟和高效率**：WebSocket无需反复地建立和关闭连接，数据可以在客户端和服务端之间流畅的传输
-   **节省带宽**：真正的双向通信，减少了HTTP长轮询的开销
-   **实时性**：应对于需要实时更新的应用场景非常使用，如实时消息、在线游戏、股票行情等

**WebSocket缺点：**

-   服务器长期维护长连接需要一定的成本

-   各个浏览器支持程度不一

-   WebSocket 是长连接，受网络限制比较大，需要处理好重连



**结论：**WebSocket并不能完全取代HTTP，它只适合在特定的场景下使用



**WebSocket的握手过程**

WebSocket使用HTTP升级机制，由常规的HTTP请求升级到WebSocket连接。在握手的过程中，客户端发送一个包含特殊头（如`Upgrade`、`Connection`）的HTTP请求，服务器解析并确认该请求，将连接升级为WebSocket，这一过程主要通过以下HTTP请求头来实现：

-   `Upgrade: websocket`
-   `Connection: upgrade`



**HTTP协议和WebSocket协议对比：**

-   HTTP是**短连接**
-   WebSocket是**长连接**
-   HTTP通信是**单向**的，基于请求响应模式
-   WebSocket支持**双向**通信
-   HTTP和WebSocket底层都是TCP连接



一些实用的WebSocket的根据：

-   **Socket.io**：一个流行的库，简化了WebSocket的使用
-   **ws**：一个轻量级的WebSocket实现，适用于 Node.js



## Cookie、Session、Token之间的区别？



## JWT Token？



## 谈谈你对CDN的理解？



## 谈谈你对DNS的理解？



## 域名解析流程？



## 当你在浏览器输入一个域名回车后，会发生什么？



## XXS跨站脚本？



## SYN Flood攻击？



## DDOS攻击？


## 说说一次完整的HTTP请求的执行流程？

>   参考：https://blog.csdn.net/2401_88326365/article/details/144849158

**口语化**

我们在浏览器输入网址，例如www.baidu.com。浏览器会进行DNS解析得到网址对应的IP地址。然后会根据IP地址找到对应的服务器建立三次握手连接。建立TCP连接后浏览器会发起HTTP请求。服务器端会响应HTTP请求，浏览器得到HTML代码。浏览器会解析HTML代码并请求HTML代码中需要的资源。接着浏览器会对页面进行渲染呈现给用户。服务器端关闭TCP连接（四次挥手）

一次完整的HTTP请求执行流程可以分为以下几个步骤：

1.  **客户端发起请求**：
    -   用户在浏览器中输入URL或点击链接，浏览器构建HTTP请求。
    -   请求包括请求行（如`GET /index.html HTTP/1.1`）、请求头（如`Host: www.example.com`）和可选的请求体。
2.  **DNS解析**：
    -   浏览器通过DNS查询将域名解析为IP地址。如果本地DNS缓存中有记录，则直接使用；否则，向DNS服务器发送查询请求。
3.  **建立TCP连接**：
    -   浏览器与服务器之间通过三次握手建立TCP连接。这确保了双方可以可靠地传输数据。
    -   三次握手过程：SYN -> SYN-ACK -> ACK
4.  **发送HTTP请求**：
    -   TCP连接建立后，浏览器通过该连接发送HTTP请求到服务器。
5.  **服务器处理请求**：
    -   服务器接收到HTTP请求后，解析请求并确定如何处理（例如，查找静态文件、调用应用程序逻辑等）。
    -   如果需要，服务器可能会查询数据库或其他资源来生成响应内容。
6.  **服务器返回响应**：
    -   服务器构建HTTP响应，包括状态行（如`HTTP/1.1 200 OK`）、响应头（如`Content-Type: text/html`）和响应体（实际内容）。
    -   服务器通过已建立的TCP连接将响应发送回客户端。
7.  **客户端接收响应**：
    -   浏览器接收到HTTP响应后，解析响应内容并渲染页面。
    -   如果响应中包含其他资源（如图片、CSS、JavaScript），浏览器会发起额外的HTTP请求来获取这些资源。
8.  **关闭TCP连接**：
    -   根据HTTP协议版本和请求头中的设置（如`Connection: keep-alive`），决定是否保持连接或关闭连接。
    -   如果是HTTP/1.1，默认情况下连接会保持打开状态以供后续请求复用；如果是HTTP/1.0或设置了`Connection: close`，则关闭连接。
9.  **渲染页面**：
    -   浏览器根据接收到的HTML文档和其他资源（如CSS、JavaScript、图片等）进行页面渲染，并最终显示给用户。