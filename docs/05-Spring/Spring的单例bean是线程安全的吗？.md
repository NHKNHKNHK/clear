# Spring的单例bean是线程安全的吗？

存在并发安全问题

在Spring中，默认情况下，Bean 是以单例（Singleton）模式创建的。因此同一个bean的实例会在整个应用程序中被多个线程共享。

在多线程环境中，**如果bean中包含全局可变状态（如实例变量或非线程安全资源），则可能会引发线程安全问题**



>   其实这个问题本质上是考察并发环境下对共享资源的操作
>
>   单例bean其实就是某个类的对象，因此单例bean是否线程安全就转变为了类是否线程安全
>
>   类是否线程安全，取决于你代码是怎么写的。即属性、方法是怎么写的。
>
>   单例bean可能会被多个线程访问，类中的方法可以被多个线程同时访问，方法有没有进行锁的控制？会不会有些共享资源在方法中进行读写呢？这都是你编写代码所需要考虑的事情，与spring无关。
>
>   所以问题就转变为了如何保证方法的线程安全了，与spring无关。



## **解决方案**

-   避免在单例bean中使用可变状态：确保单例bean是无状态的或适用线程安全的数据结构

-   将单例bean中可能需要操作读写的实例变量放在方法局部中（这也是无状态的处理方案）

如果变量一定要定义为实例变量，可采用以下方式

-   使用@Scope注解，将bean设置为多例。即创建多个对象，但这种方式比较浪费内存
-   使用ThreadLocal包裹成员变量，ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。
-   在需要操作共享资源的方法上加上同步锁，但是会降低服务器吞吐量 



## **Spring如何处理线程并发问题?**

spring一般是使用ThreadLocal进行处理，解决线程安全问题。

ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。

同步机制采用了“时间换空间”的方式，仅提供一份变量，不同的线程获取锁，没获得锁的线程则需要排队。

而ThreadLocal采用了“空间换时间”的方式。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，所以没有相同变量的访问冲突问题。所以在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。

  
