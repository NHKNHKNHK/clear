# 陌陌海量数据存储案例

**案例目标**

-   能够掌握HBase表结构设计（表设计、ROWKEY设计、预分区）

-   能够安装部署Apache Phoenix

-   能够掌握Phoenix的基本操作

-   能够掌握使用Phoenix建立二级索引提升性能

-   能够基于Phoenix JDBC API编写Java代码操作HBase

## 1 案例介绍

在陌陌中，每天都有数千万的用户聊天消息需要存储。而且，这些消息都是需要进行大量地保存，而读取会少很多。想想：我们在使用微信的时候，大多数时候，我们都是在发消息，而不是每时每刻查询历史消息。要存储这样海量的数据，HBase就非常适合了，**HBase本身也非常适合存储这种写多读少的应用场景**。

本案例，将结合陌陌聊天业务背景，以HBase来存储海量的数据。

## 2 打招呼消息数据集介绍

| 字段名              | 说明           |
| ------------------- | -------------- |
| msg_time            | 消息时间       |
| sender_nickyname    | 发件人昵称     |
| sender_account      | 发件人账号     |
| sender_sex          | 发件人性别     |
| sender_ip           | 发件人IP       |
| sender_os           | 发件人系统     |
| sender_phone_type   | 发件人手机型号 |
| sender_network      | 发件人网络制式 |
| sender_gps          | 发件人GPS      |
| receiver_nickyname  | 收件人昵称     |
| receiver_ip         | 收件人IP       |
| receiver_account    | 收件人账号     |
| receiver_os         | 收件人系统     |
| receiver_phone_type | 收件人手机型号 |
| receiver_network    | 收件人网络制式 |
| receiver_gps        | 收件人GPS      |
| receiver_sex        | 收件人性别     |
| msg_type            | 消息类型       |
| distance            | 双方距离       |
| message             | 消息           |

## 3  准备工作

### 3.1  创建IDEA Maven项目

| groupId   | artifactId    | version      |
| --------- | ------------- | ------------ |
| com.clear | momo_chat_app | 1.0-SNAPSHOT |

### 3.2  在项目中创建存放hbase shell脚本目录

在项目下创建名为 hbase_shell 的目录

在项目下创建一个 readme.md 文件，如下：

```shell
# 陌陌海量消息存储说明文档
## 1. 项目结构说明
* hbase_shell：用于存放hbase shell操作脚本
* momo_chat_app：Java API数据接口
```

### 3.3 创建脚本文件

在hbase_shell下创建名为 create_ns_table.rb 文件，用于编写Hbase相关脚本，并使用VSCode打开项目文件夹

## 4  陌陌消息HBase表结构设计

### 4.1  **名称空间**

#### 4.1.1  **说明**

-   在一个项目中，需要使用HBase保存多张表，这些表会按照业务域来划分

-   为了方便管理，不同的业务域以名称空间（namespace)来划分，这样管理起来会更加容易

-   类似于Hive中的数据库，不同的数据库下可以放不同类型的表

-   **HBase默认的名称空间是「default」，默认情况下，创建表时表都将创建在 default 名称空间下**

-   **HBase中还有一个命名空间「hbase」，用于存放系统的内建表（namespace、meta）**

#### 4.1.2  语法

```shell
# 创建命名空间
create_namespace 'MOMO_CHAT'

# 查看命名空间列表
list_namespace

# 查看命名空间
describe_namespace 'MOMO_CHAT'

# 命名空间创建表
# 	在命令MOMO_CHAT命名空间下创建名为：MSG的表，该表包含一个名为C1的列蔟
# 	注意：带有命名空间的表，使用**冒号**将命名空间和表名连接到一起。
create 'MOMO_CHAT:MSG','C1'

# 删除之前创建的表
disable 'MOMO_CHAT:MSG'
drop 'MOMO_CHAT:MSG'

# 删除命名空间
#	删除命名空间，命名空间中必须没有表，如果命名空间中有表，是无法删除的
drop_namespace 'MOMO_CHAT'
```



### 4.2  **列蔟设计**

-   HBase列蔟的数量应该越少越好
    -   两个及以上的列蔟HBase性能并不是很好（**推荐使用1到2个列簇**）
    -   一个列蔟所存储的数据达到flush的阈值时，表中所有列蔟将同时进行flush操作
    -   这将带来不必要的I/O开销，列蔟越多，对性能影响越大

-   本次项目中我们只设计一个列蔟：C1

    

### 4.3  **版本设计**

#### 4.3.1  **说明**

-   此处，我们需要保存的历史聊天记录是不会更新的，一旦数据保存到HBase中，就不会再更新

-   无需考虑版本问题

-   本次项目中只保留一个版本即可，这样可以节省大量空间

-   HBase默认创建表的版本为1，故此处保持默认即可

#### 4.3.2  **查看表**

通过以下输出可以看到：

-   版本是相对于列蔟而言

-   默认列蔟的版本数为1

```shell
hbase(main):018:0> describe 'MOMO_CHAT:MSG'
Table MOMO_CHAT:MSG is ENABLED                                                                                                                               
MOMO_CHAT:MSG                                                                                                                                                
COLUMN FAMILIES DESCRIPTION                                                                                                                                  
{NAME => 'C1', BLOOMFILTER => 'ROW', IN_MEMORY => 'false', VERSIONS => '1', KEEP_DELETED_CELLS => 'FALSE', DATA_BLOCK_ENCODING => 'NONE', COMPRESSION => 'NON
E', TTL => 'FOREVER', MIN_VERSIONS => '0', BLOCKCACHE => 'true', BLOCKSIZE => '65536', REPLICATION_SCOPE => '0'}                                             

1 row(s)
Quota is disabled
Took 0.0596 seconds        
```

### 4.4  **数据压缩**

#### 4.4.1  **压缩算法**

在HBase可以使用多种压缩编码，包括LZO、SNAPPY、GZIP。

只在硬盘压缩，内存中或者网络传输中没有压缩。

**数据压缩：在创建表的时候，可以针对列簇指定数据压缩方式**（如果表已经存在，也可以使用alter修改）

| **压缩算法** | **压缩后占比** | **压缩** | **解压缩** |
| ------------ | -------------- | -------- | ---------- |
| GZIP         | 13.4%          | 21 MB/s  | 118 MB/s   |
| LZO          | 20.5%          | 135 MB/s | 410 MB/s   |
| Zippy/Snappy | 22.2%          | 172 MB/s | 409 MB/s   |

-   GZIP的压缩率最高，但是其实CPU密集型的，对CPU的消耗比其他算法要多，压缩和解压速度也慢；

-   LZO的压缩率居中，比GZIP要低一些，但是压缩和解压速度明显要比GZIP快很多，其中解压速度快的更多；

-   Zippy/Snappy的压缩率最低，而压缩和解压速度要稍微比LZO要快一些

**本案例采用GZ算法，这样可以确保的压缩比最大化，更加节省空间**

#### 4.4.2  **查看表数据压缩方式**

通过以下输出可以看出，HBase创建表默认是没有指定压缩算法的

```shell
hbase(main):018:0> describe 'MOMO_CHAT:MSG'
Table MOMO_CHAT:MSG is ENABLED                                                                                                                               
MOMO_CHAT:MSG                                                                                                                                                
COLUMN FAMILIES DESCRIPTION                                                                                                                                  
{NAME => 'C1', BLOOMFILTER => 'ROW', IN_MEMORY => 'false', VERSIONS => '1', KEEP_DELETED_CELLS => 'FALSE', DATA_BLOCK_ENCODING => 'NONE', COMPRESSION => 'NON
E', TTL => 'FOREVER', MIN_VERSIONS => '0', BLOCKCACHE => 'true', BLOCKSIZE => '65536', REPLICATION_SCOPE => '0'}                     			                        

1 row(s)
Quota is disabled
Took 0.0596 seconds        

# 从 COMPRESSION => 'NONE' 可以看出Hbase表默认是没有指定压缩算法
```

#### 4.4.3  **设置数据压缩**

本案例中，我们使用GZ压缩算法，语法如下：

-   创建新的表，并指定数据压缩算法

```shell
create "MOMO_CHAT:MSG", {NAME => "C1", COMPRESSION => "GZ"}
```

-   修改已有的表，并指定数据压缩算法

```shell
alter "MOMO_CHAT:MSG", {NAME => "C1", COMPRESSION => "GZ"}
```



### 4.5  **ROWKEY设计原则**

#### 4.5.1  **HBase官方的设计原则**

##### 4.5.1.1  避免使用递增行键/时序数据

如果ROWKEY设计的都是按照顺序递增（例如：时间戳），这样会有很多的数据写入时，负载都在一台机器上。我们尽量应当将写入大压力均衡到各个RegionServer

##### 4.5.1.2  避免ROWKEY和列的长度过大

-   在HBase中，要访问一个Cell（单元格），需要有ROWKEY、列蔟、列名，如果ROWKEY、列名太大，就会占用较大内存空间。所以ROWKEY和列的长度应该尽量短小

-   ROWKEY的最大长度是64KB，建议越短越好

##### 4.5.1.3  使用long等类型比String类型更省空间

long类型为8个字节，8个字节可以保存非常大的无符号整数，例如：18446744073709551615。如果是字符串，是按照一个字节一个字符方式保存，需要快3倍的字节数存储。

##### 4.5.1.4  ROWKEY唯一性

-   设计ROWKEY时，必须保证RowKey的唯一性

-   由于在HBase中数据存储是Key-Value形式，若向HBase中同一张表插入相同RowKey的数据，则原先存在的数据会被新的数据覆盖。

#### 4.5.2  **避免数据热点**

-   热点是指大量的客户端（client）直接访问集群的一个或者几个节点（可能是读、也可能是写）

-   大量地访问量可能会使得某个服务器节点超出承受能力，导致整个RegionServer的性能下降，其他的Region也会受影响

##### 4.5.2.1  **预分区**

-   默认情况，一个HBase的表只有一个Region，被托管在一个RegionServer中

![1697987628539](images\mm_1.png)

 

-   每个Region有两个重要的属性：Start Key、End Key，表示这个Region维护的ROWKEY范围

-   如果只有一个Region，那么Start Key、End Key都是空的，没有边界。所有的数据都会放在这个Region中，但当数据越来越大时，会将Region分裂，取一个Mid Key来分裂成两个Region

-   预分区个数 = 节点的倍数。默认Region的大小为10G，假设我们预估1年下来的大小为10T，则10000G / 10G = 1000个Region，所以，我们可以预设为1000个Region，这样，1000个Region将均衡地分布在各个节点上

##### 4.5.2.2  **ROWKEY避免热点设计**

1. **反转策略**

-   如果设计出的ROWKEY在数据分布上不均匀，但ROWKEY尾部的数据却呈现出了良好的随机性，可以考虑**将ROWKEY的翻转**，或者直接将尾部的bytes提前到ROWKEY的开头。

-   反转策略可以使ROWKEY随机分布，但是牺牲了ROWKEY的有序性

-   缺点：利于Get操作，但不利于Scan操作，因为数据在原ROWKEY上的自然顺序已经被打乱

2. **加盐策略**

-   Salting（加盐）的原理是在原ROWKEY的**前面**添加固定长度的随机数，也就是给ROWKEY分配一个随机前缀使它和之间的ROWKEY的开头不同

-   随机数能保障数据在所有Regions间的负载均衡

-   缺点：因为添加的是随机数，基于原ROWKEY查询时无法知道随机数是什么，那样在查询的时候就需要去各个可能的Regions中查找，加盐对比读取是无力的

3. **哈希策略**

-   基于 ROWKEY的完整或部分数据进行 Hash，而后将Hashing后的值完整替换或部分替换原ROWKEY的前缀部分

-   这里说的 hash 包含 MD5、sha1、sha256 或 sha512 等算法

-   缺点：Hashing 也不利于 Scan，因为打乱了原RowKey的自然顺序

#### 4.5.3  **陌陌打招呼数据预分区**

##### 4.5.3.1  **预分区**

-   在创建表的时候，配置一些策略，让一个table有多个region，分布在多个不同RegionServer中
-   HBase会自动进行split，如果一个region，HBase会自动split成两个，就是根据rowkey来横向切分

在HBase中，可以通过指定start key、end key来进行分区，还可以直接指定Region的数量，指定分区的策略。

1.指定 start key、end key来分区

```shell
hbase> create 'ns1:t1', 'f1', SPLITS => ['10', '20', '30', '40']	# 这里分了五个region
hbase> create 't1', 'f1', SPLITS => ['10', '20', '30', '40']
hbase> create 't1', 'f1', SPLITS_FILE => 'splits.txt', OWNER => 'johndoe'
```

2.指定分区数量、分区策略

```shell
hbase> create 't1', 'f1', {NUMREGIONS => 15, SPLITALGO => 'HexStringSplit'}
```

**分区策略**

-   HexStringSplit: ROWKEY是十六进制的字符串作为前缀的

-   DecimalStringSplit: ROWKEY是10进制数字字符串作为前缀的

-   UniformSplit: ROWKEY前缀完全随机

 

Region的数量可以按照数据量来预估。本次案例，**因为受限于虚拟机，所以我们设计为6个Region。**因为ROWKEY我们是使用多个字段拼接，而且前缀不是完全随机的，所以需要使用HexStringSplit。



##### 4.5.3.2  **ROWKEY设计**

-   反转：例如，手机号码、时间戳，可以将手机号码反转
-   加盐：在rowkey前面加上随机数，加上随机数后，就会导致数据查询不出来，因为HBase默认是没有二级索引的
-   hash：根据rowkey中的某个部分取hash，因为hash每次计算都是一样的值。所以，我们可以用hash操作获取数据
-   这几种策略，因为要将数据均匀分布在集群中的每个RegionServer，所以其核心就是吧rowkey打散后放入到集群节点中，所以数据不再是有序的存储，会导致scan的效率下降

为了确保数据均匀分布在每个Region，需要以MD5Hash作为前缀：

​		 **ROWKEY = MD5Hash\_发件人账号\_收件人账号\_时间戳**

![1697987811798](D:\video\Typora文档-7.26\hbase\images\mm_2.png)

 

##### 4.5.3.3  业务分区脚本

```shell
hbase(main):023:0> create 'MOMO_CHAT:MSG', {NAME => "C1", COMPRESSION => "GZ"}, {NUMREGIONS => 6, SPLITALGO => 'HexStringSplit'}
Created table MOMO_CHAT:MSG
Took 2.1549 seconds                                                                                                                                          
=> Hbase::Table - MOMO_CHAT:MSG

# 查看
hbase(main):024:0> describe 'MOMO_CHAT:MSG'
Table MOMO_CHAT:MSG is ENABLED                                                                                                                               
MOMO_CHAT:MSG                                                                                                                                                
COLUMN FAMILIES DESCRIPTION                                                                                                                                  
{NAME => 'C1', BLOOMFILTER => 'ROW', IN_MEMORY => 'false', VERSIONS => '1', KEEP_DELETED_CELLS => 'FALSE', DATA_BLOCK_ENCODING => 'NONE', COMPRESSION => 'GZ'
, TTL => 'FOREVER', MIN_VERSIONS => '0', BLOCKCACHE => 'true', BLOCKSIZE => '65536', REPLICATION_SCOPE => '0'}                                               

1 row(s)
```

 执行完命令后，我们发现该表已经分为6个分区。这样将来数据就可以均匀地分布到不同的分区中了

**注意：勾选ShowDetailName&Start/EndKey，点击Recorder**

![1697988124898](images\mm_3.png) 

HDFS中，也有对应的6个文件夹

URL：/hbase/data/MOMO_CHAT/MSG

![1697988214632](images\mm_4.png)

 

## 5 项目初始化

### 5.1  **导入POM依赖**

```xml
<repositories><!-- 代码库 -->
    <repository>
        <id>aliyun</id>
        <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>false</enabled>
            <updatePolicy>never</updatePolicy>
        </snapshots>
    </repository>
</repositories>

<dependencies>
    <!-- HBase客户端 -->
    <dependency>
        <groupId>org.apache.hbase</groupId>
        <artifactId>hbase-client</artifactId>
        <version>2.1.0</version>
    </dependency>
    <!-- 依赖Lombok插件，生成冗余的getter、setter、toString等方法 -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.28</version>
        <scope>provided</scope>
    </dependency>

    <!-- Xml操作相关 -->
    <dependency>
        <groupId>com.github.cloudecho</groupId>
        <artifactId>xmlbean</artifactId>
        <version>1.5.5</version>
    </dependency>
    <!-- 操作Office库 -->
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi</artifactId>
        <version>4.0.1</version>
    </dependency>
    <!-- 操作Office库 -->
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi-ooxml</artifactId>
        <version>4.0.1</version>
    </dependency>
    <!-- 操作Office库 -->
    <dependency>
        <groupId>org.apache.poi</groupId>
        <artifactId>poi-ooxml-schemas</artifactId>
        <version>4.0.1</version>
    </dependency>
    <!-- 操作JSON -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>fastjson</artifactId>
        <version>1.2.62</version>
    </dependency>
    <!-- phoenix core -->
    <dependency>
        <groupId>org.apache.phoenix</groupId>
        <artifactId>phoenix-core</artifactId>
        <version>5.0.0-HBase-2.0</version>
    </dependency>
    <!-- phoenix 客户端 -->
    <dependency>
        <groupId>org.apache.phoenix</groupId>
        <artifactId>phoenix-queryserver-client</artifactId>
        <version>5.0.0-HBase-2.0</version>
    </dependency>

    <!-- SLF4J API -->
    <!-- SLF4J是一个抽象层，它提供了统一的日志接口，可以与不同的日志实现框架（如Logback、Log4j等）进行交互 -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>1.7.32</version>
    </dependency>

    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-log4j12</artifactId>
        <version>1.7.32</version>
    </dependency>
</dependencies>


<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.1</version>
            <configuration>
                <target>1.8</target>
                <source>1.8</source>
            </configuration>
        </plugin>
    </plugins>
</build>
```



### 5.2  拷贝配置文件

将Linux服务器中的以下几个文件拷贝到resources目录

-   **core-site.xml**
    -   sz /opt/software/hadoop-3.1.3/etc/hadoop/core-site.xml

-   **hbase-site.xml**
    -   sz /opt/software/hbase-2.3.4/conf/hbase-site.xml

-   **log4j.properties**
    -   sz /opt/software/hbase-2.3.4/conf/log4j.properties 

### 5.3  **创建包结构**

| com.clear.hbase.momo_chat.service      | 用于存放数据服务接口相关代码，例如：查询的API代码       |
| -------------------------------------- | ------------------------------------------------------- |
| com.clear.hbase.momo_chat.service.impl | 用于存放数据服务接口实现类相关代码，例如：查询的API代码 |
| com.clear.hbase.momo_chat.tool         | 工具类                                                  |
| com.clear.hbase.momo_chat.entity       | 存放实体类                                              |

### 5.4  导入ExcelReader工具类

ExcelReader工具类可以读取Excel中的数据称为HashMap这样，方便我们快速生成数据。

```java
package com.clear.hbase.momo_chat.tool;

import org.apache.poi.openxml4j.opc.OPCPackage;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.util.*;
import java.util.logging.Logger;

public class ExcelReader {
    private static Logger log = Logger.getLogger("client");

    public static void main(String[] args) {
        String xlxsPath = "src/main/resources/测试数据集.xlsx";
        Map<String, List<String>> mapData = readXlsx(xlxsPath, "陌陌数据");

        for(int i = 0; i < 10000; ++i) {
            System.out.println(randomColumn(mapData, "sender_nickyname"));
        }
    }

    /**
     * 随机获取某一列的数据
     * @param columnName 列名
     * @return 随机数据
     */
    public static String randomColumn(Map<String, List<String>> resultMap, String columnName) {
        List<String> valList = resultMap.get(columnName);

        if(valList == null) throw new RuntimeException("未读取到列名为" + columnName + "的任何数据!");
        Random random = new Random();

        int randomIndex = random.nextInt(valList.size());

        return valList.get(randomIndex);
    }

    /**
     * 将Excel文件读取为Map结构: <column_name, list>
     * 其中column_name为第4行的名字
     * @param path Excel文件路径（要求Excel为2007）
     * @param sheetName 工作簿名称
     * @return Map结构
     */
    public static Map<String, List<String>> readXlsx(String path, String sheetName)
    {
        // 列的数量
        int columnNum = 0;
        // HashMap<String, List<String>>  ==> HashMap<列名, 每一列的数据>
        HashMap<String, List<String>> resultMap = new HashMap<String, List<String>>();
        ArrayList<String> columnList = new ArrayList<String>();

        try
        {
            OPCPackage pkg= OPCPackage.open(path);
            XSSFWorkbook excel=new XSSFWorkbook(pkg);
            //获取sheet
            XSSFSheet sheet=excel.getSheet(sheetName);

            // 加载列名
            XSSFRow columnRow = sheet.getRow(3);
            if(columnRow == null) {
                throw new RuntimeException("数据文件读取错误!请确保第4行为英文列名!");
            }
            else {
                Iterator<Cell> colIter = columnRow.iterator();
                // 迭代所有列
                while(colIter.hasNext()) {
                    Cell cell = colIter.next();
                    String colName = cell.getStringCellValue();
                    columnList.add(colName);
                    columnNum++;
                }
            }

            System.out.println("读取到:" + columnNum + "列");
            System.out.println(Arrays.toString(columnList.toArray()));

            // 初始化resultMap
            for(String colName : columnList) {
                resultMap.put(colName, new ArrayList<String>());
            }

            // 迭代sheet
            Iterator<Row> iter = sheet.iterator();
            int i = 0;
            int rownum = 1;

            while(iter.hasNext()) {
                Row row = iter.next();
                Iterator<Cell> cellIter = row.cellIterator();

                // 跳过前4行
                if(rownum <= 4) {
                    ++rownum;
                    continue;
                }

                while(cellIter.hasNext()) {
                    XSSFCell cell=(XSSFCell) cellIter.next();
                    //根据单元的的类型,读取相应的结果
                    if(cell.getCellType() == CellType.NUMERIC) {
                        resultMap.get(columnList.get(i % columnList.size())).add(Double.toString(cell.getNumericCellValue()));
                    }
                    else {
                        resultMap.get(columnList.get(i % columnList.size())).add(cell.getStringCellValue());
                    }

                    ++i;
                    ++rownum;
                }
            }
        }
        catch (Exception e) {
            e.printStackTrace();
        }

        return resultMap;
    }
}
```

ExcelReader工具类主要有两个方法：

​	1）readXlsx——用于将指定路径的Excel文件中的工作簿读取为Map结构

​	2）randomColumn——随机生成某一列中的数据。

### 5.5  **创建实体类**

在com.clear.hbase.momo_chat.entity包中创建一个名为Msg的实体类，使用Java代码描述陌陌消息。

| **字段名**          | **说明**       |
| ------------------- | -------------- |
| msg_time            | 消息时间       |
| sender_nickyname    | 发件人昵称     |
| sender_account      | 发件人账号     |
| sender_sex          | 发件人性别     |
| sender_ip           | 发件人IP       |
| sender_os           | 发件人系统     |
| sender_phone_type   | 发件人手机型号 |
| sender_network      | 发件人网络制式 |
| sender_gps          | 发件人GPS      |
| receiver_nickyname  | 收件人昵称     |
| receiver_ip         | 收件人IP       |
| receiver_account    | 收件人账号     |
| receiver_os         | 收件人系统     |
| receiver_phone_type | 收件人手机型号 |
| receiver_network    | 收件人网络制式 |
| receiver_gps        | 收件人GPS      |
| receiver_sex        | 收件人性别     |
| msg_type            | 消息类型       |
| distance            | 双方距离       |
| message             | 消息           |

参考代码：

```java
package com.clear.hbase.momo_chat.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Msg {
    private String msg_time;  // 消息时间
    private String sender_nickyname;  // 发件人昵称
    private String sender_account;  // 发件人账号
    private String sender_sex;  // 发件人性别
    private String sender_ip;  // 发件人
    private String IPsender_os;  // 发件人系统
    private String sender_phone_type;  // 发件人手机型号
    private String sender_network;  // 发件人网络制式
    private String sender_gps;  // 发件人GPS
    private String receiver_nickyname;  // 收件人昵称
    private String receiver_ip;  // 收件人
    private String IPreceiver_account;  // 收件人账号
    private String receiver_os;  // 收件人系统
    private String receiver_phone_type;  // 收件人手机型号
    private String receiver_network;  // 收件人网络制式
    private String receiver_gps;  // 收件人GPS
    private String receiver_sex;  // 收件人性别
    private String msg_type;  // 消息类型
    private String distance;  //双方距离
    private String message;  // 消息
}
```



## 6  **编写数据生成器**

### 6.1  测试工具类ExcelReader读取测试数据集

​	1）在com.clear.hbase.momo_chat.tool包中创建一个名为MoMoMsgGen类

​	2）在main方法中，读取src/main/resouces中的测试数据集.xlsx 

```java
public static void main(String[] args) {
    // 读取Excel文件中的数据
    Map<String, List<String>> resultMap =
        ExcelReader.readXlsx("src/main/resources/测试数据集.xlsx", "陌陌数据");
    System.out.println(resultMap);
}
```



### 6.2  **随机生成一条数据**

编写getOneMsg方法，调用ExcelReader工具类，随机生成一条陌陌消息数据

实现步骤：

​	1）构建Msg实体类对象

​	2）调用ExcelReader工具类中的randomColumn随机生成一个列的数据

​	3）注意时间使用系统当前时间

参考代码：

```java
/**
 * 随机生成一条数据
 * @param resultMap
 * @return
 */
private static Msg getOneMsg(Map<String, List<String>> resultMap) {
    Msg msg = new Msg();
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    long timestamp = new Date().getTime();

    msg.setMsg_time(sdf.format(timestamp));
    msg.setSender_nickyname(ExcelReader.randomColumn(resultMap, "sender_nickyname"));
    msg.setSender_account(ExcelReader.randomColumn(resultMap, "sender_account"));
    msg.setSender_sex(ExcelReader.randomColumn(resultMap, "sender_sex"));
    msg.setSender_ip(ExcelReader.randomColumn(resultMap, "sender_ip"));
    msg.setSender_os(ExcelReader.randomColumn(resultMap, "sender_os"));
    msg.setSender_phone_type(ExcelReader.randomColumn(resultMap, "sender_phone_type"));
    msg.setSender_network(ExcelReader.randomColumn(resultMap, "sender_network"));
    msg.setSender_gps(ExcelReader.randomColumn(resultMap, "sender_gps"));
    msg.setReceiver_nickyname(ExcelReader.randomColumn(resultMap, "receiver_nickyname"));
    msg.setReceiver_ip(ExcelReader.randomColumn(resultMap, "receiver_ip"));
    msg.setReceiver_account(ExcelReader.randomColumn(resultMap, "receiver_account"));
    msg.setReceiver_os(ExcelReader.randomColumn(resultMap, "receiver_os"));
    msg.setReceiver_phone_type(ExcelReader.randomColumn(resultMap, "receiver_phone_type"));
    msg.setReceiver_network(ExcelReader.randomColumn(resultMap, "receiver_network"));
    msg.setReceiver_gps(ExcelReader.randomColumn(resultMap, "receiver_gps"));
    msg.setReceiver_sex(ExcelReader.randomColumn(resultMap, "receiver_sex"));
    msg.setMsg_type(ExcelReader.randomColumn(resultMap, "msg_type"));
    msg.setDistance(ExcelReader.randomColumn(resultMap, "distance"));
    msg.setMessage(ExcelReader.randomColumn(resultMap, "message"));

    return msg;
}
```



### 6.3  **构建ROWKEY**

前面我们分析得到：

ROWKEY = MD5Hash\_发件人账号\_收件人账号\_消息时间戳

​	1）其中MD5Hash的计算方式为：发送人账号 + “\_” + 收件人账号 + “_” + 消息时间戳 

​	2）使用MD5Hash.getMD5AsHex方法生成MD5值

​	3）取MD5值的前8位，避免过长

​	4）最后把发件人账号、收件人账号、消息时间戳和MD5拼接起来

实现步骤：

​	1）创建getRowkey方法，接收Msg实体对象，并根据该实体对象生成byte[]的rowkey

​	2）使用StringBuilder将发件人账号、收件人账号、消息时间戳使用下划线（_）拼接起来

​	3）使用Bytes.toBytes将拼接出来的字符串转换为byte[]数组

​	4）使用MD5Hash.getMD5AsHex生成MD5值，并取其前8位

​	5）再将MD5值和之前拼接好的发件人账号、收件人账号、消息时间戳，再使用下划线拼接，转换为Bytes数组

参考代码：

```java
/**
 * 构建行键rowkey：
 * MD5Hash_发件人账号_收件人账号_消息时间戳
 *
 * @param msg Msg实体，也就是一条消息的对象表示
 * @return
 */
private static byte[] getRowkey(Msg msg) throws ParseException {
    String senderAccount = msg.getSender_account(); // 发件人账号
    String receiverAccount = msg.getReceiver_account();  // 收件人账号
    String msgTime = msg.getMsg_time();     // 消息时间戳
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    long time = sdf.parse(msgTime).getTime();

    // 构建RowKey
    StringBuilder stringBuilder = new StringBuilder()
        .append(senderAccount)
        .append("_")
        .append(receiverAccount)
        .append("_")
        .append(time);

    byte[] orginkey = Bytes.toBytes(stringBuilder.toString());

    // 为了避免ROWKEY过长，取前八位
    String md5AsHex = MD5Hash.getMD5AsHex(orginkey).substring(0, 8);

    return Bytes.toBytes(md5AsHex + "_" + stringBuilder.toString());
}
```



### 6.4  数据写入HBase

实现步骤：

​	1）获取Hbase连接

​	2）获取HBase表MOMO_CHAT:MSG

​	3）初始化操作Hbase所需的变量（列蔟、列名）

​	4）构建put请求

​	5）挨个添加陌陌消息的所有列

​	6）发起put请求

#### 6.4.1  **构建Hbase连接**

1）获取Hbase连接

```java
Configuration configuration = HBaseConfiguration.create();
Connection connection = ConnectionFactory.createConnection(configuration);
```

2）获取HBase表

```java
String TABLE_NAME = "MOMO_CHAT:MSG";
Table momoChatlTable = connection.getTable(TableName.valueOf(TABLE_NAME));
```

3）初始化操作Hbase所需的变量（列蔟、列名）

```java
String cf_name = "C1";
String col_msg_time = "msg_time";
String col_sender_nickyname = "sender_nickyname";
String col_sender_account = "sender_account";
String col_sender_sex = "sender_sex";
String col_sender_ip = "sender_ip";
String col_sender_os = "sender_os";
String col_sender_phone_type = "sender_phone_type";
String col_sender_network = "sender_network";
String col_sender_gps = "sender_gps";
String col_receiver_nickyname = "receiver_nickyname";
String col_receiver_ip = "receiver_ip";
String col_receiver_account = "receiver_account";
String col_receiver_os = "receiver_os";
String col_receiver_phone_type = "receiver_phone_type";
String col_receiver_network = "receiver_network";
String col_receiver_gps = "receiver_gps";
String col_receiver_sex = "receiver_sex";
String col_msg_type = "msg_type";
String col_distance = "distance";
String col_message = "message";
```



#### 6.4.2  **发起put请求添加数据**

1）构建put请求

2）挨个添加陌陌消息的所有列

3）发起put请求

参考代码：

```java
public static void main(String[] args) throws ParseException, IOException {
    // 读取Excel文件中的数据
    Map<String, List<String>> resultMap =
        ExcelReader.readXlsx("src/main/resources/测试数据集.xlsx", "陌陌数据");

    // todo 测试生成一条数据
    Msg msg = getOneMsg(resultMap);
    
    // todo 生成数据到HBase表中
    // 1）获取Hbase连接
    Configuration configuration = new Configuration();
    Connection connection = ConnectionFactory.createConnection(configuration);
    // 2）获取HBase表MOMO_CHAT:MSG
    String TABLE_NAME = "MOMO_CHAT:MSG";
    Table table = connection.getTable(TableName.valueOf(TABLE_NAME));
    // 3）初始化操作Hbase所需的变量（列蔟、列名）
    byte[] rowkey = getRowkey(msg);
    String columnFamily = "C1";
    String columnMsg_time = "msg_time";
    String columnSender_nickyname = "sender_nickyname";
    String columnSender_account = "sender_account";
    String columnSender_sex = "sender_sex";
    String columnSender_ip = "sender_ip";
    String columnSender_os = "sender_os";
    String columnSender_phone_type = "sender_phone_type";
    String columnSender_network = "sender_network";
    String columnSender_gps = "sender_gps";
    String columnReceiver_nickyname = "receiver_nickyname";
    String columnReceiver_ip = "receiver_ip";
    String columnReceiver_account = "receiver_account";
    String columnReceiver_os = "receiver_os";
    String columnReceiver_phone_type = "receiver_phone_type";
    String columnReceiver_network = "receiver_network";
    String columnReceiver_gps = "receiver_gps";
    String columnReceiver_sex = "receiver_sex";
    String columnMsg_type = "msg_type";
    String columnDistance = "distance";
    String columnMessage = "message";
    // 4）构建put请求
    Put put = new Put(rowkey);
    // 5）挨个添加陌陌消息的所有列
    //   指定 列簇、列名、value
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnMsg_time), Bytes.toBytes(msg.getMsg_time()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_nickyname), Bytes.toBytes(msg.getSender_nickyname()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_account), Bytes.toBytes(msg.getSender_account()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_sex), Bytes.toBytes(msg.getSender_sex()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_ip), Bytes.toBytes(msg.getSender_ip()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_os), Bytes.toBytes(msg.getSender_os()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_phone_type), Bytes.toBytes(msg.getSender_phone_type()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_network), Bytes.toBytes(msg.getSender_network()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_gps), Bytes.toBytes(msg.getSender_gps()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_nickyname), Bytes.toBytes(msg.getReceiver_nickyname()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_ip), Bytes.toBytes(msg.getReceiver_ip()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_account), Bytes.toBytes(msg.getReceiver_account()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_os), Bytes.toBytes(msg.getReceiver_os()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_phone_type), Bytes.toBytes(msg.getReceiver_phone_type()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_network), Bytes.toBytes(msg.getReceiver_network()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_gps), Bytes.toBytes(msg.getReceiver_gps()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_sex), Bytes.toBytes(msg.getReceiver_sex()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnMsg_type), Bytes.toBytes(msg.getMsg_type()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnDistance), Bytes.toBytes(msg.getDistance()));
    put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnMessage), Bytes.toBytes(msg.getMessage()));

    // 6）发起put请求
    table.put(put);
    table.close();
    connection.close();

}
```



#### 6.5  生成10W条数据

1）使用一个while循环，生成10W条数据

2）注意遍历的时候打印下数据生成的进度

完整代码：

```java
package com.clear.hbase.momo_chat.tool;

import com.clear.hbase.momo_chat.entity.Msg;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.Connection;
import org.apache.hadoop.hbase.client.ConnectionFactory;
import org.apache.hadoop.hbase.client.Put;
import org.apache.hadoop.hbase.client.Table;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.hadoop.hbase.util.MD5Hash;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 * 陌陌消息随机生成器：
 * 1.通过 ExcelReader 工具类从Excel中随机读取数据，并生成一个Msg对象
 * 2.通过设计rowkey，避免热点数据，尽量让每条数据均匀分布在每个region中（我们前面为MSG表创建了6个region）
 * 3.将Msg对象，put到HBase中
 * 4.生成10w条数据方便测试
 */
public class MoMoMsgGen {
    public static void main(String[] args) throws ParseException, IOException {
        // 读取Excel文件中的数据
        Map<String, List<String>> resultMap =
                ExcelReader.readXlsx("src/main/resources/测试数据集.xlsx", "陌陌数据");
        // System.out.println(resultMap);

        // todo 生成数据到HBase表中
        // 1）获取Hbase连接
        Configuration configuration = new Configuration();
        Connection connection = ConnectionFactory.createConnection(configuration);
        // 2）获取HBase表MOMO_CHAT:MSG
        String TABLE_NAME = "MOMO_CHAT:MSG";
        Table table = connection.getTable(TableName.valueOf(TABLE_NAME));

        int i = 0;
        int MAX = 100000;
        while (i < MAX) {
            Msg msg = getOneMsg(resultMap);

            // 3）初始化操作Hbase所需的变量（列蔟、列名）
            byte[] rowkey = getRowkey(msg);
            String columnFamily = "C1";
            String columnMsg_time = "msg_time";
            String columnSender_nickyname = "sender_nickyname";
            String columnSender_account = "sender_account";
            String columnSender_sex = "sender_sex";
            String columnSender_ip = "sender_ip";
            String columnSender_os = "sender_os";
            String columnSender_phone_type = "sender_phone_type";
            String columnSender_network = "sender_network";
            String columnSender_gps = "sender_gps";
            String columnReceiver_nickyname = "receiver_nickyname";
            String columnReceiver_ip = "receiver_ip";
            String columnReceiver_account = "receiver_account";
            String columnReceiver_os = "receiver_os";
            String columnReceiver_phone_type = "receiver_phone_type";
            String columnReceiver_network = "receiver_network";
            String columnReceiver_gps = "receiver_gps";
            String columnReceiver_sex = "receiver_sex";
            String columnMsg_type = "msg_type";
            String columnDistance = "distance";
            String columnMessage = "message";
            // 4）构建put请求
            Put put = new Put(rowkey);
            // 5）挨个添加陌陌消息的所有列
            //   指定 列簇、列名、value
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnMsg_time), Bytes.toBytes(msg.getMsg_time()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_nickyname), Bytes.toBytes(msg.getSender_nickyname()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_account), Bytes.toBytes(msg.getSender_account()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_sex), Bytes.toBytes(msg.getSender_sex()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_ip), Bytes.toBytes(msg.getSender_ip()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_os), Bytes.toBytes(msg.getSender_os()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_phone_type), Bytes.toBytes(msg.getSender_phone_type()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_network), Bytes.toBytes(msg.getSender_network()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnSender_gps), Bytes.toBytes(msg.getSender_gps()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_nickyname), Bytes.toBytes(msg.getReceiver_nickyname()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_ip), Bytes.toBytes(msg.getReceiver_ip()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_account), Bytes.toBytes(msg.getReceiver_account()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_os), Bytes.toBytes(msg.getReceiver_os()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_phone_type), Bytes.toBytes(msg.getReceiver_phone_type()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_network), Bytes.toBytes(msg.getReceiver_network()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_gps), Bytes.toBytes(msg.getReceiver_gps()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnReceiver_sex), Bytes.toBytes(msg.getReceiver_sex()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnMsg_type), Bytes.toBytes(msg.getMsg_type()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnDistance), Bytes.toBytes(msg.getDistance()));
            put.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(columnMessage), Bytes.toBytes(msg.getMessage()));

            ++i;
            // 6）发起put请求
            table.put(put);

            // 显示进度
            System.out.println(i + " / " + MAX);
        }
        table.close();
        connection.close();

    }

    /**
     * 基于从Excel表格中读取的数据随机生成一条数据（即Msg对象）
     *
     * @param resultMap 在Excel中读取的数据
     * @return Msg实例
     */
    private static Msg getOneMsg(Map<String, List<String>> resultMap) {
        // 1.构建Msg实例
        Msg msg = new Msg();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        long timestamp = new Date().getTime();  // 令当前时间为消息时间

        // 2.调用 ExcelReader 中的 randomColumn 方法，随机生成一个列的消息
        msg.setMsg_time(sdf.format(timestamp));
        msg.setSender_nickyname(ExcelReader.randomColumn(resultMap, "sender_nickyname"));
        msg.setSender_account(ExcelReader.randomColumn(resultMap, "sender_account"));
        msg.setSender_sex(ExcelReader.randomColumn(resultMap, "sender_sex"));
        msg.setSender_ip(ExcelReader.randomColumn(resultMap, "sender_ip"));
        msg.setSender_os(ExcelReader.randomColumn(resultMap, "sender_os"));
        msg.setSender_phone_type(ExcelReader.randomColumn(resultMap, "sender_phone_type"));
        msg.setSender_network(ExcelReader.randomColumn(resultMap, "sender_network"));
        msg.setSender_gps(ExcelReader.randomColumn(resultMap, "sender_gps"));
        msg.setReceiver_nickyname(ExcelReader.randomColumn(resultMap, "receiver_nickyname"));
        msg.setReceiver_ip(ExcelReader.randomColumn(resultMap, "receiver_ip"));
        msg.setReceiver_account(ExcelReader.randomColumn(resultMap, "receiver_account"));
        msg.setReceiver_os(ExcelReader.randomColumn(resultMap, "receiver_os"));
        msg.setReceiver_phone_type(ExcelReader.randomColumn(resultMap, "receiver_phone_type"));
        msg.setReceiver_network(ExcelReader.randomColumn(resultMap, "receiver_network"));
        msg.setReceiver_gps(ExcelReader.randomColumn(resultMap, "receiver_gps"));
        msg.setReceiver_sex(ExcelReader.randomColumn(resultMap, "receiver_sex"));
        msg.setMsg_type(ExcelReader.randomColumn(resultMap, "msg_type"));
        msg.setDistance(ExcelReader.randomColumn(resultMap, "distance"));
        msg.setMessage(ExcelReader.randomColumn(resultMap, "message"));

        return msg;
    }


    /**
     * 构建行键rowkey：
     * MD5Hash_发件人账号_收件人账号_消息时间戳
     *
     * @param msg Msg实体，也就是一条消息的对象表示
     * @return
     */
    private static byte[] getRowkey(Msg msg) throws ParseException {
        String senderAccount = msg.getSender_account(); // 发件人账号
        String receiverAccount = msg.getReceiver_account();  // 收件人账号
        String msgTime = msg.getMsg_time();     // 消息时间戳
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        long time = sdf.parse(msgTime).getTime();

        // 构建RowKey
        StringBuilder stringBuilder = new StringBuilder()
                .append(senderAccount)
                .append("_")
                .append(receiverAccount)
                .append("_")
                .append(time);

        byte[] orginkey = Bytes.toBytes(stringBuilder.toString());

        // 为了避免ROWKEY过长，取前八位
        String md5AsHex = MD5Hash.getMD5AsHex(orginkey).substring(0, 8);

        return Bytes.toBytes(md5AsHex + "_" + stringBuilder.toString());
    }
}
```



## 7  **编写数据服务查询数据**

### 7.1  **需求**

数据存储到HBase之后，用户可能会在某一时间按照日期来查询聊天记录。例如：用户点击某一个日期，那就需要将当天用户和另外一个用户的打招呼聊天记录查询出来。也就是需要按照以下几个字段来进行查询。

-   日期

-   发件人

-   收件人

### 7.2  **创建接口与实现类**

1） 在com.clear.hbase.momo_chat.service 包下创建ChatMessageService接口

参考如下：

```java
package com.clear.hbase.momo_chat.service;

import com.clear.hbase.momo_chat.entity.Msg;

import java.util.List;

public interface ChatMessageService {
    List<Msg> getMessage(String date, String sender, String receiver) throws Exception;
    void close();
}
```

-   getMessage表示从Hbase中的消息记录根据日期、发送者账号、接受者账号查询数据，并返回一个List集合

-   close表示关闭打开的相关资源

2）在com.clear.hbase.momo_chat.service.impl包下创建HBaseNativeChatMessageService实现类，并实现getMessage方法

参考代码：

```java
package com.clear.hbase.momo_chat.service.impl;

import com.clear.hbase.momo_chat.entity.Msg;
import com.clear.hbase.momo_chat.service.ChatMessageService;

/**
 * 使用HBase原生 Java API实现数据服务
 */
@Log4j
public class HBaseNativeChatMessageService implements ChatMessageService {
    @Override
    public List<Msg> getMessage(String date, String sender, String receiver) throws Exception {
        return null;
    }

    @Override
    public void close() {

    }
}
```



### 7.3  构建实现类所需对象并初始化

要使用该对象操作Hbase，我们需要提前准备以下内容：

1）Hbase连接

2）日期格式化器

添加几个字段，并在构造器中初始化它们

构造器实现：

1）构建HBase Connection

2）构建日期格式化器

 参考代码：

```java
private Connection connection;
private SimpleDateFormat sdf;
private ExecutorService executorServiceMsg;
private Table tableMsg;


public HBaseNativeChatMessageService() {
    try {
        Configuration configuration = HBaseConfiguration.create();
        connection = ConnectionFactory.createConnection(configuration);
        sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

        executorServiceMsg = Executors.newFixedThreadPool(5);
        tableMsg = connection.getTable(TableName.valueOf("MOMO_CHAT:MSG"), executorServiceMsg);
    } catch (IOException e) {
        logger.error("获取HBase连接失败 {}", e, e.getMessage());
    }
}
```



### 7.4  实现close方法

在close方法中关闭连接池、表、连接。

```java
@Override
public void close() {
    try {
        connection.close();
        tableMsg.close();
        executorServiceMsg.shutdown();
    } catch (IOException e) {
        logger.error("资源释放异常 {}", e, e.getMessage());
    }
}
```



### 7.5  实现getMessage方法

要根据日期、发件人、收件人查询消息，我们需要使用scan+filter来进行扫描。我们需要使用多个Filter组合起来进行查询。

实现步骤：

1）构建scan对象

2）构建用于查询时间的范围，例如：2020-10-05 00:00:00 – 2020-10-05 23:59:59

3）构建查询日期的两个Filter，大于等于、小于等于，此处过滤单个列使用SingleColumnValueFilter即可。

4）构建发件人Filter

5）构建收件人Filter

6）使用FilterList组合所有Filter

7）设置scan对象filter

8）获取HTable对象，并调用getScanner执行

9）获取迭代器，迭代每一行，同时迭代每一个单元格

参考实现：

```java
/**
 * @param date     日期 2020-10-05
 * @param sender   发件人
 * @param receiver 收件人
 * @return
 * @throws Exception
 */
 @Override
    public List<Msg> getMessage(String date, String sender, String receiver) throws Exception {
        // 1）构建scan对象
        Scan scan = new Scan();
        // 2）构建用于查询时间的范围，例如：2020-10-05 00:00:00 – 2020-10-05 23:59:59
        String startDate = date + " 00:00:00";
        String endDate = date + " 23:59:59";
        // 3）构建查询日期的两个Filter，大于等于、小于等于，此处过滤单个列使用SingleColumnValueFilter即可。
        SingleColumnValueFilter startDateFilter = new SingleColumnValueFilter(Bytes.toBytes("C1")
                , Bytes.toBytes("msg_time"),
                // >=
                CompareOperator.GREATER_OR_EQUAL,
                new BinaryComparator(Bytes.toBytes(startDate + "")));
        SingleColumnValueFilter endDateFilter = new SingleColumnValueFilter(Bytes.toBytes("C1")
                , Bytes.toBytes("msg_time"),
                // <=
                CompareOperator.GREATER_OR_EQUAL,
                new BinaryComparator(Bytes.toBytes(endDate + "")));
        // 4）构建发件人Filter
        SingleColumnValueFilter senderFilter = new SingleColumnValueFilter(Bytes.toBytes("C1")
                , Bytes.toBytes("sender_account"),
                CompareOperator.EQUAL,
                new BinaryComparator(Bytes.toBytes(sender)));
        // 5）构建收件人Filter
        SingleColumnValueFilter receiverFilter = new SingleColumnValueFilter(Bytes.toBytes("C1")
                , Bytes.toBytes("receiver_account"),
                CompareOperator.EQUAL,
                new BinaryComparator(Bytes.toBytes(receiver)));

        // 6）使用FilterList组合所有Filter
        FilterList filterList = new FilterList(FilterList.Operator.MUST_PASS_ALL,   // 必须全部满足
                senderFilter,
                receiverFilter,
                startDateFilter,
                endDateFilter);

        // 7）设置scan对象filter
        scan.setFilter(filterList);
        // 8）获取HTable对象，并调用getScanner执行
        ResultScanner scanner = tableMsg.getScanner(scan);
        // 9）获取迭代器，迭代每一行，同时迭代每一个单元格
        Iterator<Result> iterator = scanner.iterator();
        // 创建一个容器，用于存储查询出来的数据
        ArrayList<Msg> msgList = new ArrayList<>();

        while (iterator.hasNext()) {
            Result result = iterator.next();
            Msg msg = new Msg();
            // 遍历所有的列：这里也可以 result.listCells得到单元格列表再遍历
            while (result.advance()) {
                Cell cell = result.current();
                String columnName = Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(),
                        cell.getQualifierLength());
                if ("msg_time".equals(columnName)) {
                    msg.setMsg_time(Bytes.toString(cell.getValueArray(), cell.getValueOffset(),
                            cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_nickyname")) {
                    msg.setSender_nickyname(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_account")) {
                    msg.setSender_account(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_sex")) {
                    msg.setSender_sex(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_ip")) {
                    msg.setSender_ip(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_os")) {
                    msg.setSender_os(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_phone_type")) {
                    msg.setSender_phone_type(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_network")) {
                    msg.setSender_network(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_gps")) {
                    msg.setSender_gps(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_nickyname")) {
                    msg.setReceiver_nickyname(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_ip")) {
                    msg.setReceiver_ip(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_account")) {
                    msg.setReceiver_account(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_os")) {
                    msg.setReceiver_os(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_phone_type")) {
                    msg.setReceiver_phone_type(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_network")) {
                    msg.setReceiver_network(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_gps")) {
                    msg.setReceiver_gps(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_sex")) {
                    msg.setReceiver_sex(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("msg_type")) {
                    msg.setMsg_type(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("distance")) {
                    msg.setDistance(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("message")) {
                    msg.setMessage(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
            }
            msgList.add(msg);
        }
        return msgList;
    }

```



### 7.6  **测试**

调用查询方法，检查是否能够根据指定的条件查询出数据

参考代码：

```java
package com.clear.hbase.momo_chat.service;

import com.clear.hbase.momo_chat.entity.Msg;
import com.clear.hbase.momo_chat.service.impl.HBaseNativeChatMessageService;
import org.junit.Test;

import java.util.List;

public class ChatMessageServiceTest {
    private ChatMessageService chatMessageService;

    public ChatMessageServiceTest()  {
        this.chatMessageService = new HBaseNativeChatMessageService();
    }
    @Test
    public void testGetMessage() throws Exception {
        List<Msg> message = chatMessageService.getMessage("2020-09-10","13514684105","13869783495");
        message.forEach(System.out::println);
    }
}
```



### 7.7  **完整代码**

```java
package com.clear.hbase.momo_chat.service.impl;

import com.clear.hbase.momo_chat.entity.Msg;
import com.clear.hbase.momo_chat.service.ChatMessageService;
import lombok.extern.log4j.Log4j;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.CompareOperator;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.*;
import org.apache.hadoop.hbase.filter.BinaryComparator;
import org.apache.hadoop.hbase.filter.FilterList;
import org.apache.hadoop.hbase.filter.SingleColumnValueFilter;
import org.apache.hadoop.hbase.util.Bytes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 使用HBase原生 Java API实现数据服务
 */
public class HBaseNativeChatMessageService implements ChatMessageService {

    private static final Logger logger = LoggerFactory.getLogger(HBaseNativeChatMessageService.class);
    private Connection connection;
    private SimpleDateFormat sdf;
    private ExecutorService executorServiceMsg;
    private Table tableMsg;


    public HBaseNativeChatMessageService() {
        try {
            Configuration configuration = HBaseConfiguration.create();
            connection = ConnectionFactory.createConnection(configuration);
            sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

            executorServiceMsg = Executors.newFixedThreadPool(5);
            tableMsg = connection.getTable(TableName.valueOf("MOMO_CHAT:MSG"), executorServiceMsg);
        } catch (IOException e) {
            logger.error("获取HBase连接失败 {}", e, e.getMessage());
        }
    }


    /**
     * 根据日期、发件人、收件人查询消息
     * @param date     日期 2020-10-05
     * @param sender   发件人
     * @param receiver 收件人
     * @return
     * @throws Exception
     */
    @Override
    public List<Msg> getMessage(String date, String sender, String receiver) throws Exception {
        // 1）构建scan对象
        Scan scan = new Scan();
        // 2）构建用于查询时间的范围，例如：2020-10-05 00:00:00 – 2020-10-05 23:59:59
        String startDate = date + " 00:00:00";
        String endDate = date + " 23:59:59";
        // 3）构建查询日期的两个Filter，大于等于、小于等于，此处过滤单个列使用SingleColumnValueFilter即可。
        SingleColumnValueFilter startDateFilter = new SingleColumnValueFilter(Bytes.toBytes("C1")
                , Bytes.toBytes("msg_time"),
                // >=
                CompareOperator.GREATER_OR_EQUAL,
                new BinaryComparator(Bytes.toBytes(startDate + "")));
        SingleColumnValueFilter endDateFilter = new SingleColumnValueFilter(Bytes.toBytes("C1")
                , Bytes.toBytes("msg_time"),
                // <=
                CompareOperator.GREATER_OR_EQUAL,
                new BinaryComparator(Bytes.toBytes(endDate + "")));
        // 4）构建发件人Filter
        SingleColumnValueFilter senderFilter = new SingleColumnValueFilter(Bytes.toBytes("C1")
                , Bytes.toBytes("sender_account"),
                CompareOperator.EQUAL,
                new BinaryComparator(Bytes.toBytes(sender)));
        // 5）构建收件人Filter
        SingleColumnValueFilter receiverFilter = new SingleColumnValueFilter(Bytes.toBytes("C1")
                , Bytes.toBytes("receiver_account"),
                CompareOperator.EQUAL,
                new BinaryComparator(Bytes.toBytes(receiver)));

        // 6）使用FilterList组合所有Filter
        FilterList filterList = new FilterList(FilterList.Operator.MUST_PASS_ALL,   // 必须全部满足
                senderFilter,
                receiverFilter,
                startDateFilter,
                endDateFilter);

        // 7）设置scan对象filter
        scan.setFilter(filterList);
        // 8）获取HTable对象，并调用getScanner执行
        ResultScanner scanner = tableMsg.getScanner(scan);
        // 9）获取迭代器，迭代每一行，同时迭代每一个单元格
        Iterator<Result> iterator = scanner.iterator();
        // 创建一个容器，用于存储查询出来的数据
        ArrayList<Msg> msgList = new ArrayList<>();

        while (iterator.hasNext()) {
            Result result = iterator.next();
            Msg msg = new Msg();
            // 遍历所有的列：这里也可以 result.listCells得到单元格列表再遍历
            while (result.advance()) {
                Cell cell = result.current();
                String columnName = Bytes.toString(cell.getQualifierArray(), cell.getQualifierOffset(),
                        cell.getQualifierLength());
                if ("msg_time".equals(columnName)) {
                    msg.setMsg_time(Bytes.toString(cell.getValueArray(), cell.getValueOffset(),
                            cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_nickyname")) {
                    msg.setSender_nickyname(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_account")) {
                    msg.setSender_account(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_sex")) {
                    msg.setSender_sex(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_ip")) {
                    msg.setSender_ip(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_os")) {
                    msg.setSender_os(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_phone_type")) {
                    msg.setSender_phone_type(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_network")) {
                    msg.setSender_network(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("sender_gps")) {
                    msg.setSender_gps(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_nickyname")) {
                    msg.setReceiver_nickyname(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_ip")) {
                    msg.setReceiver_ip(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_account")) {
                    msg.setReceiver_account(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_os")) {
                    msg.setReceiver_os(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_phone_type")) {
                    msg.setReceiver_phone_type(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_network")) {
                    msg.setReceiver_network(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_gps")) {
                    msg.setReceiver_gps(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("receiver_sex")) {
                    msg.setReceiver_sex(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("msg_type")) {
                    msg.setMsg_type(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("distance")) {
                    msg.setDistance(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
                if (columnName.equalsIgnoreCase("message")) {
                    msg.setMessage(Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength()));
                }
            }
            msgList.add(msg);
        }
        return msgList;
    }

    @Override
    public void close() {
        try {
            connection.close();
            tableMsg.close();
            executorServiceMsg.shutdown();
        } catch (IOException e) {
            logger.error("资源释放异常 {}", e, e.getMessage());
        }
    }
}
```



## 6  **性能问题**

-   Hbase默认只支持对行键的索引，那么如果要针对其它的列来进行查询，就只能全表扫描

-   上述的查询是使用scan + filter组合来进行查询的，但查询地效率不高，因为要进行顺序全表扫描而没有其他索引。如果数据量较大，只能在客户端（client）来进行处理，如果要传输到Client大量的数据，然后交由客户端处理
    -   网络传输压力很大
    -   客户端的压力很大

-   如果表存储的数据量很大时，效率会非常低下，此时需要使用二级索引

-   也就是除了ROWKEY的索引外，还需要人为添加其他的方便查询的索引

如果每次需要我们开发二级索引来查询数据，这样使用起来很麻烦。再者，查询数据都是HBase Java API，使用起来不是很方便。为了让其他开发人员更容易使用该接口。如果有一种SQL引擎，通过SQL语句来查询数据会更加方便。

此时，使用Apache Phoenix就可以解决我们上述问题。