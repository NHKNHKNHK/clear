# 如何禁止别人调式前端页面代码

> 参考：https://juejin.cn/post/7262175454714626108?searchId=202504181531366D88A76DB15E3E135EA5#heading-6


在前端开发中，我们无法完全阻止别人调试前端页面代码，但可以通过一些技术手段和安全策略来增加调试难度。

以下是常见的实现方案：
- 无限 debugger
- 禁用右键：利用js禁用右键，可以减少用户通过右键菜单进行检查和调试的机会
- 禁用 F12 和开发者工具：利用js禁用F12键以及其他可以打开开发者工具的快捷键（如Ctrl+Shift+I），从而阻止用户使用开发者工具
- 代码混淆和压缩：如通过webpack等打包工具对代码进行混淆和压缩，使代码变得难以理解
- 检测开关开发者工具：利用js定期检测是否打开了开发者工具，如果打开了则重载页面，从而阻止用户使用开发者工具
    - 如： 窗口尺寸监听，打开了开发者工具，窗口尺寸会改变



## **无限 debugger**

```javascript
// 基础版：每50ms触发一次断点
setInterval(() => { debugger }, 50);

// 增强版：动态生成不可格式化代码
new Function('while(1) debugger')();

// 终极版：加密混淆后的检测
const antiDebug = Function('return ' + '(!window.devtools ? ' +
  '(window.devtools = {}) : ' +
  '(window.location.reload(), false)')();
antiDebug();
```

:::tip

通过火狐浏览器打开网页，可以直接绕过无限 debugger

:::

## **禁用右键**

比如说利用js禁用右键点击事件
```javascript
document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
})
```
不过这种方式只能应对小白，但凡有点经验的人都可以绕过这种方式



## **禁用 F12 和开发者工具**

可以利用js捕获F12或其他快捷键的按键事件来组织它们被使用
```javascript
document.onKeydown = function (e) {
    if (e.keyCode === 123 ) { // F12
        return false;
    }
    if (e.ctrlKey && e.shiftKey && e.keyCode === 'I'.charCodeAt(0)) { // Ctrl + Shift + I
        return false;
    }
    if (e.ctrlKey && e.shiftKey && e.keyCode === 'C'.charCodeAt(0)) { // Ctrl + Shift + C
        return false;
    }
    if (e.ctrlKey && e.shiftKey && e.keyCode === 'J'.charCodeAt(0)) { // Ctrl + Shift + J
        return false;
    }
    if (e.ctrlKey && e.keyCode === 'U'.charCodeAt(0)) { // Ctrl + U
        return false;
    }
}
```
这种方式也只能阻止一些初级开发者



## **代码混淆、加密、压缩**

例如使用Webpack、UglifyJS等工具，对js代码进行混淆、加密、压缩。

混淆

```
# 使用UglifyJS进行高级混淆
uglify-js src/app.js -o dist/app.min.js \
  --mangle --compress \
  --toplevel --mangle-props \
  --name-cache --source-map
```
混淆后，一般变量名、函数名都会被替换成无意义的短字符串，从而增加理解代码的难度

**字符串加密**

```javascript
// 原始代码
console.log('Hello World');

// 加密后
const _0x1234 = String.fromCharCode;
const _0x5678 = [_0x1234(72, 101, 108, 108, 111), _0x1234(32, 87, 111, 114, 108, 100)];
console[_0x1234(108, 111, 103)](_0x5678.join(''));
```

**压缩**

```javascript
// 原始代码
function hello() {
    console.log('Hello World');
}

// 压缩后
function hello() {console.log('Hello World')}
```
这个压缩的例子可能不是很明显，但是真是项目中的代码不可能这么简单，压缩后就很难阅读了



## **窗口尺寸监听**

可以通过定期检测窗口尺寸的变化，如果窗口尺寸变化幅度过大，则认为用户打开了开发者工具，从而 reload 页面。

```javascript
setInterval(() => {
 if (window.outerHeight - window.innerHeight > 200 || window.outerWidth - window.innerWidth > 200) {
    alert('检测到开发者工具打开');
    window.location.reload(); 
  }
}, 500);
```

## **console 对象劫持检测**

```javascript
const originalConsole = window.console;
const antiConsole = new Proxy(originalConsole, {
  get(target, key) {
    if (['log', 'warn', 'error'].includes(key)) {
      // 检测到控制台输出，可能正在调试
      window.location.href = 'https://example.com/blocked';
    }
    return target[key];
  }
});
window.console = antiConsole;
```



## **动态代码注入**

```javascript
// 按需加载关键模块
const loadModule = async (moduleName) => {
  const script = document.createElement('script');
  script.src = `https://cdn.example.com/modules/${moduleName}.js?${Date.now()}`;
  script.onload = () => {
    window[moduleName](); // 执行动态注入的代码
  };
  document.head.appendChild(script);
};

// 使用时动态加载
loadModule('paymentProcessor');
```

## **安全提示**

尽管在前端开发中，我们可以通过一些技术手段来阻止别人调试前端页面代码，但客户端代码始终是运行在用户的浏览器中，因此无法完全避免被调试和查看。
对于真正关键的逻辑和数据，应该尽量在后端实现，并通过确保API安全调用等措施确保安全