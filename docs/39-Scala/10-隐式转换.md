---
permalink: /scala/scala-implicit-conversion
---

# 隐式转换

## 1 隐式转换简介

在类型系统中，**自动类型转换**就是**精度小的类型可以自动转换为精度大的类型**，这个转换过程无需开发人员参与，由**编译器自动完成**，这个转换操作我们称之为**隐式转换**。

在其他的场合，隐式转换也起到了非常重要的作用。如Scala在程序编译错误时，可以通过隐式转换中**类型转换机制**尝试进行**二次编译**，将本身错误无法编译通过的代码通过类型转换后编译通过。慢慢地，这也形成了一种**扩展功能**的转换机制。

## 2 隐式函数

可以定义一个隐式转换函数，将一个类型转换为另一个类型。隐式转换函数通常定义在一个特殊的隐式转换类中

```scala
object ScalaImplicit {
    def main(args: Array[String]): Unit = {
        implicit def transform( d : Double ): Int = {
            d.toInt
        }
        var d : Double = 2.0
        val i : Int = d
        println(i)
    }
}
```



## 3 隐式参数 & 隐式变量

**隐式参数**：可以**为方法定义一个隐式参数**，当调用该方法时，**编译器会自动查找符合该参数类型的隐式值**



```scala
object ScalaImplicit {
    def main(args: Array[String]): Unit = {
        def transform( implicit  d : Double ) = {	// 隐式参数
            d.toInt
        }
        implicit val dd : Double = 2.0	// 隐式变量
        println(transform)
    }
}
```

## 4 隐式类

​	在Scala2.10后提供了**隐式类**，可以**使用implicit声明**类，隐式类非常强大，同样可以扩展类的功能，在集合的数据处理中，隐式类发挥了重要的作用。

-   其所带的构造参数有且只能有一个
-   隐式类必须被定义在“类”或“伴生对象”或“包对象”里，即隐式类不能是顶级的。


```scala
object ScalaImplicit {
    def main(args: Array[String]): Unit = {
        val emp = new Emp()
        emp.insertUser()
    }
    class Emp {
    }
    implicit class User( emp : Emp) {  // 隐式类
        def insertUser(): Unit = {
            println("insert user...")
        }
    }
}
```



## 5 隐式机制

所谓的隐式机制，就是一旦出现编译错误时，编译器会从哪些地方查找对应的隐式转换规则

-   当前代码作用域

-   当前代码上级作用域

-   当前类所在的包对象

-   当前类（对象）的父类（父类）或特质（父特质）


其实最直接的方式就是直接导入。
