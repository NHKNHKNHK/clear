---
permalink: /25/8/17/scala/scala-pattern-matching
---

# 模式匹配

## 1 模式匹配简介

Scala中的**模式匹配类似于Java中的 switch语法**，但是scala从语法中补充了更多的功能，可以按照指定的规则对数据或对象进行匹配，
所以更加强大。

```scala
int i = 20；
switch (i) {
    case 10 :
  	  	System.out.println("10");
   	  	break;
    case 20 : 
    	System.out.println("20");
    	break;
    default : 
    	System.out.println("other number");
    	break;
}
```

## 2 基本语法

**模式匹配语法中，采用`match`关键字声明，每个分支采用`case`关键字进行声明**

当需要匹配时，会从第一个case分支开始，如果匹配成功，那么执行对应的逻辑代码，如果匹配不成功，继续执行下一个分支进行判断。

如果所有case都不匹配，那么会执行`case _`分支（类似于Java中default语句）

如果不存在`case _`分支，那么会发生错误。

```scala
object ScalaMatch{
    def main(args: Array[String]): Unit = {
        var a: Int = 10
        var b: Int = 20
        var operator: Char = 'd'
        var result = operator match {
            case '+' => a + b	// 如果匹配成功，字段中断，不需要break
            case '-' => a - b
            case '*' => a * b
            case '/' => a / b
            case _ => "illegal"	 // 类似于Java中的 default
        }
        println(result)
    }
}
```

## 3 **匹配规则**

### 3.1 匹配常量

```scala
def describe(x: Any) = x match {
    case 5 => "Int five"
    case "hello" => "String hello"
    case true => "Boolean true"
    case '+' => "Char +"
}
```

### 3.2 匹配类型

```scala
def describe(x: Any) = x match {
    case i: Int => "Int"
    case s: String => "String hello"
    case m: List[_] => "List"
    case c: Array[Int] => "Array[Int]"
    case someThing => "something else " + someThing
}
```

### 3.3 匹配数组

```scala
def describe(x: Any) = x match {
    case i: Int => "Int"
    case s: String => "String hello"
    case m: List[_] => "List"
    case c: Array[Int] => "Array[Int]"
    case someThing => "something else " + someThing
}
```

### 3.4 匹配列表

```scala
for (list <- Array(List(0), List(1, 0), List(0, 0, 0), List(1, 0, 0), List(88))) {
    val result = list match {
        case List(0) => "0" //匹配List(0)
        case List(x, y) => x + "," + y //匹配有两个元素的List
        case List(0, _*) => "0 ..."
        case _ => "something else"
    }

    println(result)
}
val list: List[Int] = List(1, 2, 5, 6, 7)

list match {
    case first :: second :: rest => println(first + "-" + second + "-" + rest)
    case _ => println("something else")
}
```

### 3.5 匹配元组

```scala
for (tuple <- Array((0, 1), (1, 0), (1, 1), (1, 0, 2))) {
    val result = tuple match {
        case (0, _) => "0 ..." //是第一个元素是0的元组
        case (y, 0) => "" + y + "0" // 匹配后一个元素是0的对偶元组
        case (a, b) => "" + a + " " + b
        case _ => "something else" //默认
    }
    println(result)
}
```

### 3.6 匹配对象

```scala
class User(val name: String, val age: Int)
object User{
    def apply(name: String, age: Int): User = new User(name, age)
    def unapply(user: User): Option[(String, Int)] = {
        if (user == null)
            None
        else
            Some(user.name, user.age)
    }
}

val user: User = User("zhangsan", 11)
val result = user match {
    case User("zhangsan", 11) => "yes"
    case _ => "no"
}
```

### 3.7 样例类

-   样例类就是使用`case`关键字声明的类

-   样例类仍然是类，和普通类相比，只是其自动生成了伴生对象，并且伴生对象中自动提供了一些常用的方法，如apply、**unapply**、toString、equals、hashCode和copy。

-   样例类是为**模式匹配**而优化的类，因为其默认提供了unapply方法，因此，样例类可以直接使用模式匹配，而无需自己实现unapply方法。

-   构造器中的每一个参数都成为val，除非它被显式地声明为var（不建议这样做）


```scala
case class User(name: String, var age: Int)

object ScalaCaseClass {
    def main(args: Array[String]): Unit = {
        val user: User = User("zhangsan", 11)
        val result = user match {
            case User("zhangsan", 11) => "yes"
            case _ => "no"
        }

        println(result)
    }
}
```



## 4 应用场景

### 4.1 变量声明

```scala
object ScalaMatch { 
    def main(args: Array[String]): Unit = {
        val (x, y) = (1, 2)
        println(s"x=$x,y=$y")

        val Array(first, second, _*) = Array(1, 7, 2, 9)
        println(s"first=$first,second=$second")

        val Person(name, age) = Person("zhangsan", 16)
        println(s"name=$name,age=$age")
    }
    case class Person(name: String, age: Int)
}
```

### 4.2 循环匹配

```scala
object ScalaMatch {
    def main(args: Array[String]): Unit = {
        val map = Map("A" -> 1, "B" -> 0, "C" -> 3)
        for ((k, v) <- map) { //直接将map中的k-v遍历出来
            println(k + " -> " + v) //3个
        }
        println("----------------------")
        //遍历value=0的 k-v ,如果v不是0,过滤
        for ((k, 0) <- map) {
            println(k + " --> " + 0) // B->0
        }
        println("----------------------")
        //if v == 0 是一个过滤的条件
        for ((k, v) <- map if v >= 1) {
            println(k + " ---> " + v) // A->1 和 c->33
        }
    }
}
```



### 4.3 函数参数

```scala
object ScalaMatch {
    def main(args: Array[String]): Unit = {
        val list = List(
            ("a", 1), ("b", 2), ("c", 3)
        )
        val list1 = list.map {
            case ( k, v ) => {
                (k, v*2)
            }
        }
        println(list1)
    }
}
```

## 5 偏函数

所谓的偏函数，其实就是对集合中符合条件的数据进行处理的函数

偏函数也是函数的一种，通过偏函数我们可以方便的对输入参数做更精确的检查。例如该偏函数的输入类型为Int，但是我们只考虑数值为1的时候，数据该如何处理，其他不考虑。

### 5.1 基本语法

```scala
// 声明偏函数
val pf: PartialFunction[Int, String] = { case 1 => "one" }

。。。
// 应用偏函数
println(List(1, 2, 3, 4).collect(pf))
```

### 5.2 **案例实操**

将该List(1,2,3,4,5,6,"test")中的Int类型的元素加一，并去掉字符串。

-   不使用偏函数

```scala
List(1,2,3,4,5,6,"test").filter(_.isInstanceOf[Int]).map(_.asInstanceOf[Int] + 1).foreach(println)
```

-   使用偏函数

```scala
List(1, 2, 3, 4, 5, 6, "test").collect { case x: Int => x + 1 }.foreach(println)
```

