---
permalink: /design-pattern/singleton-enum
---

# 枚举为什么是实现单例最好的方式？

:::tip
《Effective Java》

使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。
:::

究其原因，主要有以下三个好处：

- 枚举实现的单例写法简单
- 枚举实现的单例天然是线程安全的
- 枚举实现的单例可避免被反序列化破坏

## 枚举单例实现简单

大多数实现单例的方式都比较复杂。主要原因是在考虑线程安全问题。


我们简单对比下“双重校验锁”方式和枚举方式实现单例的代码。

双重校验锁实现单例：

```java
public class DclSingleton {
    // todo 创建对象，不是原子性操作，即使使用了双重检查锁，也可能在创建过程中产生半初始状态
    // volatile如果不加可能会出现半初始化的对象
    // 现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）,为了兼容性我们加上
    private volatile static DclSingleton INSTANCE;

    private DclSingleton() {
    }

    public static DclSingleton getInstance() {
        if (null == INSTANCE) {
            synchronized (DclSingleton.class) {
                if (null == INSTANCE) {
                    INSTANCE = new DclSingleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

枚举实现单例：

```java
public enum EnumSingleton {
    // todo 对于枚举类，任何一个枚举项都是天然的单例
    INSTANCE;
}
```

## 枚举可解决线程安全问题

使用非枚举的方式实现单例，需要我们自己来保证线程安全

而使用枚举类来实现单例，枚举项它天然就是单例的

接下来我们看看它为什么是天然单例

```java
public enum T {
    SPRING, SUMMER, AUTUMN, WINTER;
}
```

上面这个枚举类反编译后代码为：

```java
public final class T extends Enum
{
    //省略部分内容
    public static final T SPRING;
    public static final T SUMMER;
    public static final T AUTUMN;
    public static final T WINTER;
    private static final T ENUM$VALUES[];
    static
    {
        SPRING = new T("SPRING", 0);
        SUMMER = new T("SUMMER", 1);
        AUTUMN = new T("AUTUMN", 2);
        WINTER = new T("WINTER", 3);
        ENUM$VALUES = (new T[] {
            SPRING, SUMMER, AUTUMN, WINTER
        });
    }
}
```

可以看到，枚举中的各个枚举项都是通过`static`来定义的。这一切都与**JVM的类加载机制**有关，下面我们使用大白话来解释：

`static`类型的属性会在类加载过程时被初始化，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的
（因为虚拟机在加载枚举的类的时候，会使用`ClassLoader`的`loadClass`方法，而这个方法使用同步代码块保证了线程安全）。
所以，创建一个enum类型是线程安全的。

也就是说，我们定义的一个枚举，在第一次被真正用到的时候，才会被虚拟机加载并初始化，而这个初始化过程是线程安全的。
而我们知道，解决单例的并发问题，主要解决的就是初始化过程中的线程安全问题。

所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的。

## 枚举可解决反序列化会破坏单例的问题

**对于普通的单例对象来说，反序列化过程中会通过Java 的 Unsafe 机制来创建对象的。**这意味着即使类的构造函数是私有的，反序列化仍然可以创建该类的实例，因为它不依赖于常规的构造过程。

但是，枚举的反序列化并不是通过Unsafe，也不是通过反射实现的。所以，也就不会发生由于反序列化导致的单例破坏问题。