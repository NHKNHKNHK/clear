---
permalink: /design-pattern/singleton-destroy
---

# 如何破坏单例模式

## 口语化

单例设计模式的核心是将类的构造器私有化，然后提供一个方法来获取单例对象，进而避免避免重复创建多个对象，
那么，想要破坏单例模式，就是要想办法获取到这个私有构造器。

首先，最容易想到的就是反射，反射可以获取到私有构造器

其次就是序列化与反序列化也可以破坏单例，先将获取到的单例对象序列化到文件，再反序列化就可以创建一个新的对象

## 反射破坏单例

核心思路是通过反射获取私有构造器，然后执行私有构造器即可创建对象

```java
@Test
public void testReflect() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
    Class<DclSingleton> clazz = DclSingleton.class;
    Constructor<DclSingleton> constructor = clazz.getDeclaredConstructor();
    constructor.setAccessible(true);

    boolean flag = DclSingleton.getInstance() == constructor.newInstance();

    log.info("flag -> {}", flag);
}
```

说明：`setAccessible(true)` 使得反射对象在使用时应该取消 Java 语言访问检查，使得私有的构造器能够被访问。

### 如何避免

反射是调用默认的构造器创建出来的，只要改造构造器，就可以在反射调用时阻止

```java{6-9}
public class DclSingleton {
    // volatile如果不加可能会出现半初始化的对象
    private volatile static DclSingleton INSTANCE;

    private DclSingleton() {
        // todo 不让其使用反射创建对象
        if (INSTANCE != null){
            throw new RuntimeException("该实例只允许实例化一次!!!");
        }
    }

    public static DclSingleton getINSTANCE() {
        if (null == INSTANCE) {
            synchronized (DclSingleton.class) {
                if (null == INSTANCE) {
                    INSTANCE = new DclSingleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

```java


```

## 反序列化破坏单例

核心思路就是先将获取到的单例对象序列化到文件，再反序列化就可以创建一个新的对象

```java
@Test
public void testSerialize() throws IOException, ClassNotFoundException {
    // 获取单例并序列化
    DclSingleton instance = DclSingleton.getInstance();
    FileOutputStream fos = new FileOutputStream("D://singleton.txt");
    ObjectOutputStream oos = new ObjectOutputStream(fos);
    oos.writeObject(instance);

    // 将实例反序列化出来
    FileInputStream fis = new FileInputStream("D://singleton.txt");
    ObjectInputStream ois = new ObjectInputStream(fis);
    Object o = ois.readObject();

    boolean flag = instance == o;
    log.info("flag:{}", flag);
}
```

:::info
FAQ: 为什么序列化可以破坏单例了？

序列化会通过Unsafe直接分配内存的方式来创建一个新的对象。
:::

### 如何避免

解决反序列化的破坏单例，只需要我们自定义反序列化的策略就行了，就是说我们不要让他走默认逻辑一直调用到Unsafe创建对象，而是我们干预他的这个过程

`readResolve()`方法可以用于替换从流中读取的对象，在进行反序列化时，会尝试执行readResolve方法，并将返回值作为反序列化的结果，而不会克隆一个新的实例，保证jvm中仅仅有一个实例存在：


```java{24-27}
public class DclSingleton implements Serializable {

    // volatile如果不加可能会出现半初始化的对象
    private volatile static DclSingleton INSTANCE;

    private DclSingleton() {
        // todo 不让其使用反射创建对象
        if (INSTANCE != null){
            throw new RuntimeException("该实例只允许实例化一次!!!");
        }
    }

    public static DclSingleton getInstance() {
        if (null == INSTANCE) {
            synchronized (DclSingleton.class) {
                if (null == INSTANCE) {
                    INSTANCE = new DclSingleton();
                }
            }
        }
        return INSTANCE;
    }

    // todo 加上这个方法 解决反序列可能打破单例
    public Object readResolve(){
        return INSTANCE;
    }
}
```