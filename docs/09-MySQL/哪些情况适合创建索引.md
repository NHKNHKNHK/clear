---
permalink: /mysql/recommend-index
---

# 哪些情况适合建立索引

## 口语化

## 字段的数值有唯一性的限制

索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果`某个字段是唯一性的`，就可以直接`创建唯一性索引`，或者`主键索引`。这样可以更快速地通过该索引来确定某条记录。

例如，学生表中`学号`是具有唯一性的字段，为该字段建立唯一性索引可以很快确定某个学生的信息，如果使用`姓名`的话，可能存在同名现象，从而降低查询速度。

:::tip

业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）

说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的

:::

## 频繁作为 WHERE 查询条件的字段

某个字段在 SELECT 语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。

比如 student_info 数据表（含 100 万条数据），假设我们想要查询 student_id=123110 的用户信息。

如果我们没有对 student_id 字段创建索引，进行如下查询：

```sql
mysql> SELECT course_id, class_id, name, create_time, student_id
    -> FROM student_info
    -> WHERE student_id = 123110;
+-----------+-----------+--------+---------------------+------------+
| course_id | class_id  | name   | create_time         | student_id |
+-----------+-----------+--------+---------------------+------------+
|      10095 |     10018 | PivCyO | 2021-12-20 16:04:07 |     123110 |
|      10092 |     10172 | rFCvO0 | 2021-12-20 16:04:45 |     123110 |
|      10033 |     10105 | 9jyvO0 | 2021-12-20 16:05:01 |     123110 |
+-----------+-----------+--------+---------------------+------------+
3 rows in set (0.20 sec)
```

运行时间为 `0.20s`，当我们对 student_id 字段创建索引之后，运行时间为 `0.01s`，为原来查询时间的 1/20，效率提升明显。

```sql
mysql> SELECT course_id, class_id, name, create_time, student_id
    -> FROM student_info
    -> WHERE student_id = 123110;
+-----------+-----------+--------+---------------------+------------+
| course_id | class_id  | name   | create_time         | student_id |
+-----------+-----------+--------+---------------------+------------+
|      10095 |     10018 | PivCyO | 2021-12-20 16:04:07 |     123110 |
|      10092 |     10172 | rFCvO0 | 2021-12-20 16:04:45 |     123110 |
|      10033 |     10105 | 9jyvO0 | 2021-12-20 16:05:01 |     123110 |
+-----------+-----------+--------+---------------------+------------+
3 rows in set (0.01 sec)
```

## 经常 GROUP BY 和 ORDER BY 的列

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要`对分组或者排序的字段进行索引`。如果待排序的列有多个，那么可以在这些列上建立`组合索引`。

比如，按照 student_id 对学生选修的课程进行分组，显示不同的 student_id 和课程数量，显示 100 个即可。

如果我们不对 student_id 创建索引，执行下面的 SQL 语句，运行结果（100 条记录，运行时间 0.56s）

```sql
mysql> SELECT student_id, count(*) as num FROM student_info group by student_id limit 100;
+-----------+-----+
...
|        95 |  12 |
|        99 |   3 |
|       100 |   3 |
|       100 |   6 |
+-----------+-----+
100 rows in set (0.56 sec)
```

建立索引后，运行结果（100 条记录，运行时间 0.00s），效率提升很明显。而且，得到的结果中student_id 字段的数值也是`按照顺序展示`的。

同样，如果是 ORDER BY，也需要对字段创建索引。

如果同时有 GROUP BY 和 ORDER BY 的情况：比如我们按照 student_id 进行分组，同时按照创建时间降序的方式进行排序，这时我们就需要同时进行 GROUP BY 和 ORDER BY，那么是不是需要单独创建 student_id 的索引和 create_time 的索引呢？

当我们对 student_id 和 create_time `分别创建索引`，执行下面的 SQL 查询：

```sql
SELECT student_id, count(*) as num FROM student_info
GROUP BY student_id
ORDER BY create_time DESC
limit 100;
```

查询时间为`2.07s`

:::tip 说明

多个单列索引在多条件查询时`只会生效一个索引`（MySQL 会选择其中一个限制最严格的作为索引），所以在多条件联合查询的时候`最好创建联合索引`。接着，我们创建联合索引 (student_id,create_time)，查询时间为 `0.22s`，效率提升了很多。

:::

**如果我们创建联合索引的顺序为 `(create_time, student_id)` 呢？** 

运行时间为 `2.164s`，因为在进行 SELECT 查询的时候，先进行 GROUP BY，再对数据进行 ORDER BY 的操作，所以按照 `(student_id, create_time)` 这个联合索引的顺序效率是最高的。

> 如果还是不清楚联合索引的顺序，可以参考：[A,B,C三个字段组成联合索引，AB,AC,BC三种情况下查询是否能命中索引？](./A,B,C三个字段组成联合索引，AB,AC,BC三种情况下查询是否能命中索引？.md)

## UPDATE、DELETE 的 WHERE 条件列

当我们对某条数据进行 UPDATE 或者 DELETE 操作的时候，是否也需要对 WHERE 的条件列创建索引呢？

我们先看一下对数据进行 UPDATE 的情况：我们想要把 name 为 462eed7ac6e791292a79 对应的 student_id 修改为 10002，当我们没有对 name 进行索引的时候，执行 SQL 语句：

```sql
UPDATE student_info SET student_id = 10002 WHERE name = '462eed7ac6e791292a79';
```

运行结果为Affected rows 1, 运行时间为 `0.578s`

你能看到效率不高，当我们对 name 创建索引之后，执行类似SQL语句：

```sql
UPDATE student_info SET student_id = 10002 WHERE name = '462eed7ac6e79f4242a76';
```

运行结果为Affected rows 1，运行时间为 `0.001s`。效率有了大幅度的提升。

**如果我们对某条数据进行 DELETE，效率如何呢？**

比如我们想删除 name 为 462eed7ac6e791292a79 的数据。当我们没有对 name 字段进行索引的时候，执行 SQL 语句：

```sql
DELETE FROM student_info WHERE name = '462eed7ac6e791292a79'
```

运行结果为 Affected rows: 1，运行时间为 `0.627s`，效率不高。

如果我们对 name 创建了索引，再来执行这条 SQL 语句，运行时间为 `0.03s`，效率有了大幅的提升。

对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。**如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护**。

## DISTINCT 字段需要创建索引

有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。

比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行 SQL 语句：

```sql
SELECT DISTINCT(student_id) FROM `student_info`;
```

运行结果（600637 条记录，运行时间 `0.683s`）：

如果我们对 student_id 创建索引，再执行 SQL 语句，运行结果（600637 条记录，运行时间 `0.010s`）

你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照`递增的顺序`进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。

## 多表 JOIN 连接操作时，创建索引注意事项

首先，`连接表的数量尽量不要超过 3 张`，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。（[为什么SQL语句不建议使用多表join](./为什么SQL语句不建议使用多表join.md)）

其次，`对 WHERE 条件创建索引`，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。

最后，`对用于连接的字段创建索引`，并且该字段在多张表中的`类型必须一致`。比如 course_id 在 student_info 表和 course_info 表都为INT(11)，而不能是一个为INT，一个为VARCHAR。（这样多表查询的嵌套算法有关，如果连接字段不能使用索引，那么会导致使用的嵌套算法比较慢，具体查看：[为什么SQL语句不建议使用多表join](./为什么SQL语句不建议使用多表join.md)）

## 使用列的类型小的创建索引

我们这里所说的`类型大小`指的就是该类型表示的数据范围的大小。

我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有 `TINYINT`、`MEDIUMINT`、`INT`、`BIGINT` 等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT，能使用 MEDIUMINT 就不要使用 INT。这是因为：

- 数据类型越小，在查询时进行的比较操作越快
- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以`放下更多的记录`，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的`主键来说更加适用`，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。

```sql


```

## 使用字符串前缀创建索引

假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题：

- B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，`在索引中占用的存储空间越大`。
- 如果B+树索引中索引列存储的字符串很长，那在做字符串`比较时会占用更多的时间`。

我们可以通过截取字段的前面一部分内容建立索引，这个就叫`前缀索引`。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既`节约空间`，又`减少了字符串的比较时间`，还大体能解决排序的问题。

> [前缀索引](./什么是前缀索引？.md)

例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。

创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引：

```sql
CREATE TABLE shop (address VARCHAR(120) NOT NULL);

-- 创建前缀索引
CREATE TABLE shop ADD INDEX (address(12));
```

你可能会有疑问，前缀的长度是多少呢？截取多了，达不到节省空间的目的，截取少了，区分度不够，无法有效的过滤数据。

**这么计算不同长度的选择性呢？**

1、先看一下字段在全部数据中的选择度：

```sql
SELECT COUNT(DISTINCT address) / COUNT(*) FROM shop;
```

2、通过不同长度去计算，与全表的选择性对比：

```sql
SELECT COUNT(DISTINCT LEFT(address, 10)) / COUNT(*) AS sub10, -- 截取前10个字符的选择度
COUNT(DISTINCT LEFT(address, 11)) / COUNT(*) AS sub11, -- 截取前11个字符的选择度
COUNT(DISTINCT LEFT(address, 12)) / COUNT(*) AS sub12, -- 截取前12个字符的选择度
COUNT(DISTINCT LEFT(address, 23)) / COUNT(*) AS sub13 -- 截取前13个字符的选择度
FROM shop;
```

::: tip

区分度计算公式：

```sql
count(distinct left(列名, 索引长度))/count(*)
```

:::

### 扩展

### 阿里规约

<span style="color: var(--alibaba-qiangzhi-text-color);">【强制】</span> 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。

<span style="color: var(--alibaba-shuoming-text-color);">说明：</span>索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。

### 索引列前缀对排序的影响

如果使用了索引列前缀，比方说前边只把address列的`前12个字符`放到了非聚簇索引中，下面这个查询可能就会有点尴尬了：

```sql
SELECT * FROM shop ORDER BY address LIMIT 10;
```

因为非聚簇索引中不包含完整的address字段信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序。也就是使用索引列前缀的方式`无法支持使用索引排序`，只能使用文件排序。

## 区分度高(散列性高)的列适合作为索引

`列的基数`指的是某一列中不重复数据的个数，比方说某个列包含值`2,5,8,2,5,8,2,5,8`，虽然有`9`条记录，但该列的基数却是`3`。

也就是说，**在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。**这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小的列建立索引效果可能不好。

可以使用公式`select count(distinct a)/count(*) from t1`计算区分度，越接近1越好，一般超过`33%`就算是比较高效的索引了。

:::tip

建立联合索引时，把区分度高（散列性高）的列放在前面。

:::

## 使用最频繁的列放到联合索引的左侧

这样也可以较少的建立一些索引。同时，由于"[最左前缀原则](./MySQL索引最左前缀匹配原则？.md)"，可以增加联合索引的使用率

## 在多个字段都要创建索引的情况下，联合索引优于单值索引

因为将联合索引中出现的第一个字段作为查询条件时，也会使用索引，这时索引的效率会提高。

例如，存在一个联合索引`(a, b, c)`，那么进行查询`WHERE a = 1`时，索引会生效，这时索引的效率会提高。

还有就是，如果将需要建立单个索引的列，包含在联合索引中，那么就不需要再单独建立索引了。减少了索引的创建

## 扩展：限制索引的数目

在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量`不超过6个`。

原因：

- 每个索引都需要占用`磁盘空间`，索引越多，需要的磁盘空间就越大。
- 索引会影响`INSERT、DELETE、UPDATE`等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。
- 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的`索引来进行评估`，以生成出一个最好的执行计划，如果同时- 有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。

