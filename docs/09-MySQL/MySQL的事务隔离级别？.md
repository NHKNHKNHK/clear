# MySQL的事务隔离级别？

## 口语化

MySQL 主要支持四种事务隔离级别，分别是读未提交、读已提交、可重复读和串行化。

简单来说，**读未提交**就是【一个事务可以读取另一个未提交事务的数据】，可能导致脏读，即一个事务读取了另一个事务未提交的数据。如果该事务回滚，那么读到的数据将是无效的。

**读已提交**是说一个事务只能读取已经提交的事务的数据。这样可以避免脏读，但可能会出现不可重复读，即A事务读取完数据后B事务提交数据，A事务再次读取的数据和上次不相同，这就是不可重复读。

**可重复读**是说一个事务在整个过程中多次读取同一行数据时，结果是相同的。可以避免脏读和不可重复读，但可能会出现幻读。

**串行化**，这种级别下，事务完全串行化执行，避免了脏读、不可重复读和幻读。代价是并发性大大降低，事务可能会因为锁等待而阻塞。

:::tip
MySQL的默认隔离级别是可重复读（REPEATABLE READ），只能避免大部分的幻读情况，但是还是会出现幻读
:::


## **读未提交（READ UNCOMMITTED）**

-   最低隔离级别：允许一个事务读取其他事务尚未提交的数据。
-   这种情况下可能会发生**脏读**（Dirty Reads），即一个事务可以读取到另一个事务中未提交的数据。
-   是四种隔离级别中并发性能最好的，但数据安全性最差。
-   使用场景：极少使用，因为可能会导致数据不一致的问题。

```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

补充：

​	**脏读**：一个事务读取了另一个事务未提交的数据。如果该事务回滚，那么读到的数据将是无效的。

## **读已提交（READ COMMITTED ）**

-   一个事务只能读取已经提交的数据。
-   避免了脏读的发生，但仍然可能出现**不可重复读**（Non-Repeatable Reads）和“幻读”（Phantom Reads）。
-   每次查询都会读取最新的已提交数据。
-   使用场景：适用于大多数应用程序，尤其是那些对数据一致性要求较高但可以容忍不可重复读的情况。

```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

补充：

​	**不可重复读**：一个事务在读取同一行数据时，可能因为另一个事务的提交而得到不同的结果。

## **可重复读（REPEATABLE READ ）**

-   MySQL **InnoDB 默认的隔离级别**。
-   在同一个事务中的多次查询返回相同的结果集，即使在这期间有其他事务对数据进行了修改并提交。
-   能够防止脏读和不可重复读，但仍然可能出现**幻读**（Phantom Read）。
-   InnoDB 存储引擎通过多版本并发控制（**MVCC**）来实现这一级别。
-   使用场景：适用于需要保证数据一致性的场景，例如银行系统、金融交易等。

```sql 
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

补充：

​	**幻读**：一个事务在读取某个范围内的行时，另一个事务在该范围内插入了新的行（或删除了行），导致前一个事务再次读取时发现了“幻影”行

## **串行化（SERIALIZABLE ）**

-   最高的隔离级别。
-   事务被强制按顺序执行，完全避免了并发操作带来的问题，如脏读、不可重复读和幻读。
-   但是，这种隔离级别可能会导致大量的锁定，从而降低了系统的并发性能。
-   使用场景：适用于对数据一致性要求极高的场景，例如在线拍卖系统、库存管理系统等。

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

设置 MySQL 事务隔离级别的示例：

```sql
-- 设置全局事务隔离级别为可重复读 
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- 设置当前会话的事务隔离级别为读已提交 
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- 开始事务 
START TRANSACTION;
-- 在事务内进行操作 
SELECT * FROM accounts WHERE account_id ='A';
-- 提交事务 
COMMIT;

-- 查看当前会话事务隔离级别 
SELECT @@session.transaction_isolation;
-- 查看全局会话事务隔离级别 
SELECT @@global.transaction_isolation;
```

## 小结

选择合适的事务隔离级别取决于你的应用程序的具体需求和性能考虑：

-   如果你需要最高的数据一致性，可以选择 SERIALIZABLE，但要注意其性能开销。
-   如果你希望在性能和一致性之间取得平衡，REPEATABLE READ 是一个不错的选择。
-   如果你能容忍不可重复读，READ COMMITTED 可能更合适。
-   避免使用 READ UNCOMMITTED，除非你明确知道其风险并愿意接受潜在的数据不一致性

​	选择合适的隔离级别需要权衡数据一致性和系统性能之间的关系。对于大多数应用，默认的可重复读隔离级别已经能够提供足够的数据一致性和并发性能。

| **隔离级别**                | **脏读** | **不可重复读** | **幻读** |
| --------------------------- | -------- | -------------- | -------- |
| Read uncommitted (读未提交) | 存在     | 存在           | 存在     |
| Read committed (读已提交)   | ×        | 存在           | 存在     |
| Repeatable read (可重复读)  | ×        | ×              | 存在     |
| Serializable (串行化)       | ×        | ×              | ×        |


## MySQL默认隔离级别为什么是可重复读

这是一个历史遗留问题，早期MySQL的binlog只有statement格式，只会记录原SQL语句，在读未提交、读已提交下这种记录方式可能会导致主从数据不一致。

## 大厂为什么反而喜欢用RC

主要原因是为了提高并发和降低死锁概率。

因为可重复读的锁太重了，间隙锁、临键锁等，锁的不只是命中的行，还可能把范围内的行全锁住。

而读已提交（RC）就不一样，绝大部分情况下只锁自己要修改的行，再加上InnoDB的半一致性优化


::: tip 扩展
所谓半一致性读就是发现行被锁了，会看看最新版本的值符不符合更新条件，如果不符合就直接跳过，不用等锁，这样并发就大大提高了。
死锁就少了，但是可能会出现不可重复读。（大多数业务下不可重复读是不影响的，部分影响的业务通过乐观锁+版本号就能解决）
:::
