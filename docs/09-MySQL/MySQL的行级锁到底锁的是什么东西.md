# MySQL的行级锁到底锁的是什么东西

## 口语化

MySQL中，行级锁主要有记录锁（Record Locks）、间隙锁（Gap Locks）和临键锁（Next-Key Locks）。此外还有插入意向锁（Insert Intention Locks）

记录锁，锁的是索引记录

间隙锁，锁的是索引记录之间的间隙。

临键锁可以看作是记录锁和间隙锁的组合，同时锁索引记录和间隙。他的范围是左开右闭的。

## 扩展

### InnoDB中的行锁

>[InnoDB中的行锁](./MySQL锁.md#innodb-row-lock)

## MySQL的加锁原则

关于加锁规则，我是看了丁奇大佬的《MySQL实战45讲》中的文章之后理解的，他总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”：

- 原则 1：加锁的基本单位是 next-key lock。是一个前开后闭区间。

- 原则 2：查找过程中访问到的对象才会加锁。

- 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。

- 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

- 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

---

假如，数据库表中当前有以下记录：

```
id列为主键，有以下记录：
0,5,10,15,20,25
```

当我们执行`update t set d=d+1 where id = 7`的时候，由于表 t 中没有 `id=7` 的记录，所以：

- 根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 `(5,10]`；
- 根据优化 2，这是一个等值查询 (id=7)，而 `id=10` 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 `(5,10)`。

当我们执行`select * from t where id>=10 and id<11 for update`的时候：

- 根据原则 1，加锁单位是 next-key lock，会给 `(5,10]`加上 next-key lock，范围查找就往后继续找，找到 `id=15`这一行停下来
- 根据优化 1，主键 id 上的等值条件，退化成行锁，只加了 `id=10` 这一行的行锁。
- 根据原则 2，访问到的都要加锁，因此需要加 next-key lock`(10,15]`。因此最终加的是行锁 `id=10` 和 next-key lock`(10,15]`。

当我们执行`select * from t where id>10 and id<=15 for update`的时候：

- 根据原则 1，加锁单位是 next-key lock，会给 `(10,15]`加上 next-key lock，并且因为 id 是唯一键，所以循环判断到 `id=15` 这一行就应该停止了。

- 但是，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 `id=20`。而且由于这是个范围扫描，因此索引 id 上的 `(15,20]`这个 next-key lock 也会被锁上。

---

假如，数据库表中当前有以下记录：

```
c列为普通索引，有以下记录：
0,5,10,15,20,25
```

当我们执行`select id from t where c=5 lock in share mode`的时候：

-   根据原则 1，加锁单位是 next-key lock，因此会给 `(0,5]`加上 next-key lock。要注意 c 是普通索引，因此仅访问 `c=5` 这一条记录是不能马上停下来的，需要向右遍历，查到 `c=10` 才放弃。
-   根据原则 2，访问到的都要加锁，因此要给 `(5,10]`加 next-key lock。
-   根据优化 2：等值判断，向右遍历，最后一个值不满足 `c=5` 这个等值条件，因此退化成间隙锁 `(5,10)`。
-   根据原则 2 ，只有访问到的对象才会加锁，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁。

当我们执行`select * from t where c>=10 and c<11 for update`的时候：



-   根据原则 1，加锁单位是 next-key lock，会给 `(5,10]`加上 next-key lock，范围查找就往后继续找，找到 `id=15` 这一行停下来
-   根据原则 2，访问到的都要加锁，因此需要加 next-key lock`(10,15]`。
-   由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 `(5,10]` 和 `(10,15]` 这两个 next-key lock。


## 总结

以上，我们介绍了InnoDB中的锁机制，主要有三种锁，分别是Record Lock、Gap Lock和Next-Key Lock。

Record Lock表示记录锁，锁的是索引记录。 Gap Lock是间隙锁，锁的是索引记录之间的间隙。 Next-Key Lock是Record Lock和Gap Lock的组合，同时锁索引记录和间隙。他的范围是左开右闭的。

InnoDB的RR级别中，加锁的基本单位是 next-key lock，只要扫描到的数据都会加锁。唯一索引上的范围查询会访问到不满足条件的第一个值为止。

同时，为了提升性能和并发度，也有两个优化点：

-   索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
-   索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

关于锁的介绍，就是这么多了，但是其实，RR的隔离级别引入的这些锁，虽然一定程度上可解决很多如幻读这样的问题，但是也会带来一些副作用，比如并发度降低、容易导致死锁等。

后面我们再来单独介绍一下为什么RR作为InnoDB的默认级别，却"不受待见"，很多大厂都会把数据库默认级别修改为RC。

> [为什么默认RR，大厂要改成RC](./为什么默认RR，大厂要改成RC.md)
