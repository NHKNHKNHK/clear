# 索引设计原则

为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。

:::details 数据准备

**第 1 步：创建数据库、创建表**

```sql
CREATE DATABASE testdb;
USE testdb;

#1.创建学生表和课程表
CREATE TABLE `student_info` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `student_id` INT NOT NULL ,
  `name` VARCHAR(20) DEFAULT NULL,
  `course_id` INT NOT NULL ,
  `class_id` INT(11) DEFAULT NULL,
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE `course` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `course_id` INT NOT NULL ,
  `course_name` VARCHAR(40) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

**第 2 步：创建模拟数据必需的存储函数**

```sql
#函数 1：创建随机产生字符串函数

DELIMITER //
CREATE FUNCTION rand_string(n INT)
  RETURNS VARCHAR(255) #该函数会返回一个字符串
BEGIN
  DECLARE chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
  DECLARE return_str VARCHAR(255) DEFAULT '';
  DECLARE i INT DEFAULT 0;
  WHILE i < n DO
    SET return_str = CONCAT(return_str, SUBSTRING(chars_str, FLOOR(1+RAND()*52), 1));
    SET i = i + 1;
  END WHILE;
  RETURN return_str;
END //
DELIMITER ;

#函数 2：创建随机数函数

DELIMITER //
CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)
BEGIN
DECLARE i INT DEFAULT 0;
SET i = FLOOR(from_num +RAND()*(to_num - from_num+1))  ;
RETURN i;
END //
DELIMITER ;
```

创建函数，假如报错：

```txt
This function has none of DETERMINISTIC……
```

由于开启过慢查询日志 bin-log, 我们就必须为我们的 function 指定一个参数。

主从复制，主机会将写操作记录在 bin-log 日志中。从机读取 bin-log 日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql 不开启创建函数设置。

- 查看 mysql 是否允许创建函数：

```sql
show variables like 'log_bin_trust_function_creators';
```

- 命令开启：允许创建函数设置：

```sql
set global log_bin_trust_function_creators=1;    # 不加global只是当前窗口有效。
```

- mysqld重启，上述参数又会消失。永久方法：

  - windows 下：my.ini[mysqld] 加上：
  
  ```txt
  log_bin_trust_function_creators=1
  ```
  
  - Linux 下：my.cnf[mysqld] 加上：
  
  ```txt
  log_bin_trust_function_creators=1
  ```

**第 3 步：创建插入模拟数据的存储过程**

```sql
# 存储过程1：创建插入课程表存储过程

DELIMITER //
CREATE PROCEDURE  insert_course( max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
 SET autocommit = 0;    #设置手动提交事务
 REPEAT  #循环
 SET i = i + 1;  #赋值
 INSERT INTO course (course_id, course_name ) VALUES
(rand_num(10000,10100),rand_string(6));
 UNTIL i = max_num
 END REPEAT;
COMMIT;  #提交事务
END //
DELIMITER ;

# 存储过程2：创建插入学生信息表存储过程

DELIMITER //
CREATE PROCEDURE  insert_stu( max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
 SET autocommit = 0;    #设置手动提交事务
 REPEAT  #循环
 SET i = i + 1;  #赋值
 INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES
(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));
 UNTIL i = max_num
 END REPEAT;
 COMMIT;  #提交事务
END //
DELIMITER ;
```

**第 4 步：调用存储过程**

```sql
CALL insert_course(100);

CALL insert_stu(1000000);
```

:::

## 哪些情况适合创建索引

> [哪些情况适合创建索引](./哪些情况适合创建索引.md)

## 哪些情况不适合创建索引

> [哪些情况不适合创建索引](./哪些情况不适合创建索引.md)

## 小结

索引是一把双刃剑，可以提高查询效率，但是会降低插入和更新的速度并占用磁盘空间

选择索引的最终目的是为了使查询的速度变快，上面给出的是最基本的原则，但不能拘泥于上面的原则，开发中需要根据实际情况灵活运用。

## 使用索引必须遵循的原则

1. 在限制性条件下尽可能缩小查找范围，避免全表扫描；
2. 一个表中不能有太多的索引，索引并不是越多越好；
3. 不要对一些基数较小的列上建立索引，比如性别；
4. 索引列的类型尽量小，比如能用tinyint的就不用int；
5. 索引列最好不要是表达式的一部分，也不能使用函数处理

