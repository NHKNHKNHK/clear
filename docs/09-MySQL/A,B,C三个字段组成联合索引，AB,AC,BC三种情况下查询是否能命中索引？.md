---
permalink: /mysql/union-index-query-hit-index
---

# A,B,C三个字段组成联合索引，AB,AC,BC三种情况下查询是否能命中索引？

在数据库中，联合索引（也称为复合索引）是由多个列组成的单个索引。

假设我们有一个包含字段 A、B 和 C 的联合索引(A, B, C)，我们来分析在不同情况下查询是否能命中索引

在分析之前，我们需要了解几个基本原则：

## **联合索引的基本原则**

1. **最左前缀原则**：联合索引会按照定义的字段顺序进行排序。查询必须从联合索引的最左边开始，才能利用索引。
2. **连续性原则**：如果跳过了联合索引中的某个字段，那么索引在跳过的字段之后就无法继续利用。

> [MySQL索引最左前缀匹配原则？](./MySQL索引最左前缀匹配原则？.md)

## **查询情况分析**

假设我们有一个联合索引(A, B, C)，我们来分析以下几种查询情况是否能命中索引：

### 查询条件为(A, B)

```sql
SELECT * FROM table WHERE A = ? AND B = ?;
```

**能命中索引**：这个查询条件从最左边开始使用联合索引的前两个字段(A, B)，因此可以利用索引。

### 查询条件为(A, C)

```sql
SELECT * FROM table WHERE A = ? AND C = ?;
```

**能部分命中索引**：查询条件包含了联合索引的第一个字段A，因此可以利用索引来查找A的值。但是，由于跳过了字段B，对于字段C的查询将无法继续利用索引。

### 查询条件为(B, C)

```sql
SELECT * FROM table WHERE B = ? AND C = ?;
```

**不能命中索引**：查询条件没有从联合索引的最左边字段A开始，因此不能利用联合索引(A, B, C)。

### 查询条件为(A)

```sql
SELECT * FROM table WHERE A = ?;
```

**能命中索引**：查询条件只包含了联合索引的第一个字段A，可以完全利用索引。

### 查询条件为(B)

```sql
SELECT * FROM table WHERE B = ?;
```

**不能命中索引**：查询条件没有包含联合索引的最左边字段A，因此不能利用联合索引(A, B, C)。  

### 查询条件为(A, B, C)

```sql
SELECT * FROM table WHERE A = ? AND B = ? AND C = ?;
```

**能命中索引**：查询条件包含了联合索引的所有字段(A, B, C)，可以完全利用索引

## 总结与扩展

在不考虑 MySQL 8.0中的[索引跳跃扫描](./索引跳跃扫描.md)的情况下，走索引情况如下

| 查询条件 | 示例WHERE语句 | 是否命中索引 | 说明                                                         |
| --------- | ------------ | ------------ | ------------------------------------------------------------ |
| (A, B)    | where A = 3 AND B = 4 | 是           | 完全匹配联合索引的前缀部分。                                 |
| (A)       | where A = 3 | 是           | 只使用了联合索引的第一列，可以命中。                         |
| (A, B, C) | where A = 3 AND B = 4 AND C = 4 <br> where A = 3 AND B `LIKE` 'hh%' AND C = 5 | 是           | 完全匹配整个联合索引。                                       |
| (A, C)    | where A = 3 AND C = 5 | 部分         | 能够利用索引中A的部分，但C不在B之后直接出现，因此只能部分利用索引。 |
| (B, C)    | where B = 4 AND C = 5 | 否           | 没有从最左边开始连续匹配索引定义，故无法利用索引。           |
| (B)       | where B = 4 | 否           | 未包含联合索引中最左侧的列A，所以不能利用索引。              |
| (C)       | where C = 5 | 否           | 未包含联合索引中最左侧的列A，所以不能利用索引。              |
| (B, A)    | where B = 4 AND A = 3 | 是           | 同(A, B)                                                 |
| (C, A)    | where C = 5 AND A = 3 | 部分         | 同(A, C)                                                 |
| (C, B)    | where C = 5 AND B = 4 | 否           | 同(B, C)                                                 |
| (C, B, A) | where C = 5 AND B = 4 AND A = 3 | 是           | 同(A, B, C)                                                 |
| (B, A, C) | where B = 4 AND A = 3 AND C = 5 | 是           | 同(A, B, C)                                                 |

通过以上表格，可以发现，只有条件中包含 A 的才能走索引，不包含A 的都不能走索引。原因就是因为**最左前缀匹配原则**

在命中A的情况下，**AB相比于AC的性能要更好**，因为(A, B)能够完全匹配索引的前缀部分，而(A, C)由于跳过了字段B，对于字段C的查询将无法继续利用索引

最后还有一点注意点，AB和BA是一样的，WHERE 条件中的先后顺序，不影响索引的使用，因为存在优化器。具体可以查看：[where条件的顺序影响使用索引吗？](./where条件的顺序影响使用索引吗？.md)
