# Redis的内存淘汰策略？

## **口语化**

Redis 的内存淘汰策略是指当 Redis 内存使用达到上限（`maxmeory`参数配置阈值，默认是服务器的最大内存）时，redis会根据配置的内存淘汰策略把访问频繁不高的key从内存中移除掉，以腾出更多的内存空间。

Redis的内存淘汰策略一个有8种，我认为可以将它们分为5类：

-   1、**采用LRU策略**，就是把不经常使用的key直接淘汰掉
-   2、**采用LFU策略**，它在LRU的算法上做了一些优化，增加了数据的访问频次，从而确保淘汰的数据的非热点的 
-   3、**随机策略**，就是随机删除一些key
-   4、**ttl策略**，就是从设置了过期时间的key里面挑选出过期时间最近的一些key进行优先淘汰
-   5、**直接报错**，当内存不够时，直接抛出异常，这是默认的出来策略

>   扩展
>
>   另一种分类的方式，将8种淘汰策略细分为两大类，即**开启数据淘汰**和**不开启数据数据淘汰**两大类，然后开启
>
>   数据淘汰的这一类又可以细分为**基于过期时间的淘汰策略**和**全部数据的淘汰策略**。

这些策略可以在`redis.conf`文件中进行配置。我们可以根据缓存的类型和缓存使用的场景选择合适的淘汰策略

最后，我们使用缓存的时候**建议设置缓存的过期时间**。因为我们直到缓存的大概过期时间，从而更好地利用内存



Redis 的内存淘汰策略是指当 Redis 内存使用达到上限时，如何选择键进行删除以释放内存。以下是 Redis 支持的主要内存淘汰策略：

1. **noeviction**

-   **描述**：当内存达到上限时，如果需要新增数据，则直接返回错误，不淘汰任何数据。
-   **适用场景**：适用于对数据完整性要求较高的场景，不能丢失任何数据。

2. **allkeys-lru**

-   **描述**：从所有键中淘汰最近最少使用的（LRU, Least Recently Used）键。
-   **适用场景**：适用于缓存场景，优先保留最近访问的数据。

3. **volatile-lru**

-   **描述**：仅从设置了过期时间的键中淘汰最近最少使用的键。
-   **适用场景**：适用于带有 TTL 的缓存数据，优先淘汰不常用的数据。

4. **allkeys-random**

-   **描述**：从所有键中随机选择键进行淘汰。
-   **适用场景**：适用于对淘汰顺序无特殊要求的场景。

5. **volatile-random**

-   **描述**：仅从设置了过期时间的键中随机选择键进行淘汰。
-   **适用场景**：适用于带有 TTL 的缓存数据，且对淘汰顺序无特殊要求。

6. **allkeys-lfu**

-   **描述**：从所有键中淘汰最近最不常使用的（LFU, Least Frequently Used）键。
-   **适用场景**：适用于缓存场景，优先保留使用频率高的数据。

7. **volatile-lfu**

-   **描述**：仅从设置了过期时间的键中淘汰最近最不常使用的键。
-   **适用场景**：适用于带有 TTL 的缓存数据，优先淘汰使用频率低的数据。

8. **volatile-ttl**

-   **描述**：仅从设置了过期时间的键中淘汰剩余生存时间（TTL）最短的键。
-   **适用场景**：适用于带有 TTL 的缓存数据，优先淘汰即将过期的数据。

## **配置方式**

在 Redis 配置文件 `redis.conf` 中，通过 `maxmemory-policy` 参数设置内存淘汰策略。例如：

```shell
maxmemory-policy allkeys-lru
```

## **注意事项**

1.  **内存限制**：只有当 Redis 的内存使用达到 `maxmemory` 设置的限制时，才会触发淘汰策略。
2.  **数据持久化**：某些淘汰策略可能会导致数据丢失，因此需要根据业务需求选择合适的策略。
3.  **监控与调优**：通过 Redis 提供的监控工具（如 `INFO` 命令），观察内存使用情况和淘汰行为，及时调整策略

