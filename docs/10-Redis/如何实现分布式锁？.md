# 如何实现分布式锁？

## **核心思路**

我们利用redis 的`setnx`方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的哥们，等待一定时间后重试即可



## **版本一**

`setnx`、`expire`命令二者组合实现一个最简单的锁。`setnx`成功，则证明抢到锁，然后使用`expire`设置一个过期时间，防止死锁

```java
//加锁
if（redisClient.setnx(lockKey,lockValue)）{
    //设置过期时间
    redisClient.expire（lockKey，1000）;
    try{
        //业务请求
        do something  
    }catch(){
    
    }finally{
       //释放锁
       redisClient.del(lockKey);
    }
}
```

那么问题来了。`setnx` 与 `expire`不是原子的。假设刚执行完`setnx`，服务挂了，或重启，总之就是没执行`expire`，那么就变成死锁了。

## **版本二**

针对版本一的原子性问题，很容易想到了lua脚本

将`setnx`和`expire`写成**lua命令**，可以解决这个问题。

那么还有没有基于api的简单方式呢。

set有一个扩展命令。这个命令是原子的。

```
SET key value [EX seconds][PX milliseconds][NX|XX]
```

于是可以这样做

```java
//加锁
if（redisClient.set(lockKey,lockValue,"NX","EX", 1000)）{
    try{
        //业务请求
        do something  
    }catch(){
    
    }finally{
       //释放锁
       redisClient.del(lockKey);
    }
}
```

到这里，同时增加过期时间，防止死锁，此方法可以**保证加锁和增加过期时间具有原子性**

已经解决了加锁问题，那么释放锁是否有问题呢。

如果仅仅的使用`lockKey`删除，那是不是意味着多个线程的key一样，如果线程A没有执行完，锁过期了。线程B执行，加锁后，结果A执行完，把B的锁释放了。这就是A删错了人。

所以在此基础上要在释放锁在一个文章。增加唯一key标识的校验。

## **版本三**

```java
//加锁
if（redisClient.set(lockKey,uuid,"NX","EX", 1000)）{
    try{
        //业务请求
        do something  
    }catch(){
    
    }finally{
       //释放锁
        if(uuid.equals(redisClient.get(lockKey);){
             redisClient.del(lockKey);
        }
      
    }
}
```

同样的释放锁，不是原子的，也可以使用lua脚本进行解决。

至此，版本三基本已经可以满足大多数场景的使用了。

那么假设。锁释放了，业务还没执行完怎么办。这就轮到了看门狗机制和`redisson`框架上场了

