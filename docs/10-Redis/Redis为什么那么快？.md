# Redis为什么那么快？

>   首先，我声明一下，这就是一个垃圾题目。redis基于内存操作能不快吗？

## **口语化**

redis 的快主要得益于以下几个点

第一个就是纯内存的操作，相比磁盘来说，纯内存带来的速度提升非常大。

其次就是合理的数据结构和数据编码设计。像不同的数据类型所对应的底层结构都会有变化，基本上作者让我们在 O(1)的复杂度内就可以读取到我们想要的值。

还有就是redis官方表示：Redis是基于内存操作的，CPU不是Redis的性能瓶颈，**Redis的性能瓶颈是根据机器的内存和网络带宽**，既然可以使用单线程来实现，就使用单线程了！！！

基于单线程，这使得 redis 不需要考虑上下文切换的消耗。以及 redis 采取了 io 多路复用，减少了网络压力，提高了吞吐量。以上就是 redis 这么快的原因

>   关键点：内存、数据结构、单线程、io多路复用



## **纯内存**

Redis将数据存储在内存中，避免了大量访问数据库和直接读取磁盘数据的操作。内存的读写速度远超过磁盘I/O，使得Redis的数据访问非常迅速。

## **数据结构合理**

Redis内部的数据结构都是为快速读写而设计的，如跳跃表、SDS（简单动态字符串）、链表和Hash等。基本都能够在O(1)复杂度下完成大部分操作，比如 hash 的结构，想获取其中一个属性的值，非常的方便，不像数据库查询需要磁盘寻找。

## **单线程操作**

redis官方表示：Redis是基于内存操作的，CPU不是Redis的性能瓶颈，**Redis的性能瓶颈是根据机器的内存和网络带宽**，既然可以使用单线程来实现，就使用单线程了！！！

Redis采用单线程模型来处理客户端请求，**避免**了多线程带来的**上下文切换和竞争条件**。

单线程模型使得Redis不需要考虑各种锁的问题，减少了性能消耗。

但是持久化，异步删除等等是异步线程处理，但这不影响性能。不过要注意一个点，因为单线程，某个命令如果耗时太大，可能会产生阻塞，也就是我们经常说的，不要使用 keys，或者直接读整个 hash 大 key。

## **io 多路复用模型**

Redis在网络通信和磁盘写入方面采用了**异步式的IO处理**，即使用epoll多路复用技术同时处理多个网络请求，减少了I/O阻塞及上下文切换开销，提高了系统的吞吐量和响应时间。

>   相关
>
>   ​	多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。

## **专门设计的数据结构**

redis的每种数据类型对应的底层存储结构都不一样，经历过多种方式的设计。

拿 string 类型来进行说，key是string类型，底层编码包含int、embstr和raw三种

-   如果存储数字的话，是用int类型的编码。
-   如果存储非数字
    -   当字节数 小于 44字节时，使用 embstr，采用连续内存空间，内存占用更小
    -   当字节数 大于 44字节时，会转为raw模式存储



