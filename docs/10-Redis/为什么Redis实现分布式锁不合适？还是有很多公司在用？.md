# 为什么Redis实现分布式锁不合适？还是有很多公司在用？

## **口语化**

关于问题这个可以从几个方面来说

第一：使用分布式锁的目的是为了保证同一个时间只有一个JVM进程可以对共享资源进行操作

第二，根据锁的用途可以细分为两类。一类是允许多个客户端操作共享资源，称之为共享锁，这种锁一般是对共享资源具有幂等性操作的场景，主要是为了防止重复操作共享资源而频繁加锁带来的性能开销。另一类是只允许一个客户端操作共享资源，称之为排他锁，这种锁一般是用在对共享资源具有非幂等性操作的场景，也就是说需要保证在同一时刻只有一个进程或线程能够访问共享资源。

目前使用分布式锁最常用的中间件是redis和zookeeper。

## redis实现分布式锁

redis可以通过两种方式实现

第一是通过redis提供的SET key value \[EX seconds]\[PX milliseconds][NX|XX] 命令，它是set命令的扩展命令，能够保证加锁和设置过期时间的原子性。

第二是基于Redisson客户端实现分布式锁，redisson提供了分布式锁的封装方法，我们只需要调用api中的lock、unlock方法，即可实现分布式锁。因为redisson在所有的指令都是通过lua脚本执行，保证了原子性。其次，redssion通过watch dog机制来实现锁的续期，从而避免死锁等问题


## zookeeper实现分布式锁

基于zookeeper实现的方式有很多种

使用比较多的方式是通过有序节点来实现，具体来说，就是每个线程去竞争锁的时候去zookeeper中创建一个有序节点，然后根据有序节点的顺序来表示获取锁的成功状态。


## 优缺点

redis和zookeeper实现分布式锁都有它的优缺点

### redis方案

-   获取锁的方式简单粗暴，如果获取锁失败，就会不断尝试获取锁，比较消耗性能。
-   redis是AP模型，在集群模式中由于一致性会导致锁出现一些问题，即便是有redlock算法来实现，在某一些场景下也无法保证100%的可靠性

不过实际开发中，使用redis实现分布式还是比较常见的，而且大部分情况下，不会遇到这种极端复杂的场景。最重要的是，redis性能很高，在高并发场景下比较合适

### zookeeper方案

-   zookeeper实现分布式锁，zookeeper天生设计定位就是**分布式协调**，强一致性。锁的模型健壮、简单易用、适合做分布式锁。

-   如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小



对我个人而言，我比较推崇zookeeper来实现分布式锁，因为对于分布式锁实现场景来说，它应该符合CP模型，但是redis是AP模型，所有在这个点上，zookeeper会更加合适一点。至于为什么还有很多公司使用redis作为分布式锁，因为它们的业务体量不大，而且能够接受它的缺点



>   1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：
>
>   -   **C**onsistency（一致性）用户访问分布式系统中的任意节点，得到的数据必须一致
>   -   **A**vailability（可用性）用户访问分布式系统时，读或写操作总能成功。
>       -   只能读不能写，或者只能写不能读，或者两者都不能执行，就说明系统弱可用或不可用
>   -   **P**artition tolerance （分区容错性）就是分区，就是当分布式系统节点之间出现网络故障导致节点之间无法通信的情况
>
>   它们的第一个字母分别是 `C`、`A`、`P`。Eric Brewer认为任何分布式系统架构方案都不可能同时满足这3个目标，这个结论就叫做 CAP 定理。
>
>   
>
>   **矛盾**
>
>   在分布式系统中，网络不能100%保证畅通，也就是说网络分区的情况一定会存在。而我们的系统必须要持续运行，对外提供服务。所以分区容错性（`P`）是硬性指标，所有分布式系统都要满足。而在设计分布式系统时要取舍的就是一致性（`C`）和可用性（`A`）了。
>
>   具体参考：[CAP定理](https://gitee.com/ninghongkang/cloud-study-2024/blob/master/doc/13-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98/README.md#11cap%E5%AE%9A%E7%90%86)



