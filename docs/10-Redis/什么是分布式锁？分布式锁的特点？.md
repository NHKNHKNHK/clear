# 什么是分布式锁？分布式锁的特点？

## 口语化

在某时刻，只能有一个线程获取到锁，在失去连接或者异常情况，锁也能够释放。

常见的分布式锁有三种：基于mysql实现、基于redis实现、基于zookeeper实现。

mysql本身就带有锁机制，但性能一般，所以使用mysql作为分布式锁比较少见

redis作为分布式锁就非常常见了，主要是利用`setnx`这个方法，如果插入key成功，则表示获得到了锁，插入失败则表示无法获得到锁。业务完成后，通过`del`来释放锁。利用这套逻辑来实现分布式锁。

zookeeper也是企业级开发中较好的一个实现分布式锁的方案，但是一般我们的项目到会使用到redis做缓存，因此使用redis做分布式锁就自然而然了。



>   分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。
>
>   分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路

## 分布式锁应满足的条件

那么分布式锁他应该满足一些什么样的条件呢？

-   **可见性**：多个线程都能看到相同的结果

 注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说**多个进程之间都能感知到变化的意思**

-   **互斥**：互斥是分布式锁的最基本的条件，使得程序串行执行
-   **容错性**：即使某个持有锁的客户端崩溃或失去连接，锁也能够被其他客户端重新获取
-   **高可用**：程序不易崩溃，时时刻刻都保证较高的可用性
-   **高性能**：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能
-   **安全性**：安全也是程序中必不可少的一环

## 常见的分布式锁

常见的分布式锁有三种

-   1）Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见
-   2）Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用**setnx**这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁
-   3）Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案

## **分布式锁的实现方式**

### **基于数据库**

使用数据库的SELECT ... FOR UPDATE 语句或类似的行级锁机制来实现分布式锁。优点是实现简单，缺点是性能较低，依赖于数据库的高可用性。高并发情况下也会对数据库造成非常大的压力。

```sql
-- 获取锁
SELECT * FROM locks WHERE resource = 'resource_name' FOR UPDATE;

-- 释放锁
DELETE FROM locks WHERE resource = 'resource_name';
```

### **基于Redis**

Redis 提供了原子操作和高性能的特性，非常适合用来实现分布式锁。通常使用**SETNX**命令来实现

```java
// 获取锁
String result = jedis.set("lock_key", "lock_value", "NX", "PX", 30000);
if ("OK".equals(result)) {
    // 锁获取成功
}

// 释放锁
if (lock_value.equals(jedis.get("lock_key"))) {
    jedis.del("lock_key");
}
```

### **基于 Zookeeper**

Zookeeper 提供了分布式协调服务，可以用来实现分布式锁。通过创建临时顺序节点来实现锁机制。

```java
// 创建一个临时顺序节点
String path = zookeeper.create("/locks/lock-", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);

// 检查是否获取到锁
List<String> children = zookeeper.getChildren("/locks", false);
Collections.sort(children);
if (path.equals("/locks/" + children.get(0))) {
    // 获取到锁
}
```
