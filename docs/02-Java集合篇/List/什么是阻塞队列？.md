# 什么是阻塞队列？

阻塞队列（Blocking Queue）是一种特殊的队列，它在以下两种情况下会自动阻塞当前线程：

1.  **当队列为空时**，从队列中获取元素的操作将被阻塞，直到队列中有可用的元素。
2.  **当队列已满时**，向队列中插入元素的操作将被阻塞，直到队列中有空闲的空间。

阻塞队列通常用于多线程环境中的生产者-消费者模式，确保生产者和消费者之间的同步和协调。Java 提供了 `java.util.concurrent.BlockingQueue` 接口及其多个实现类来支持这种行为。

## **主要特点**

-   **线程安全**：所有操作都是线程安全的，内部使用锁机制或其他同步手段来保证并发访问的安全性。
-   **阻塞特性**：提供阻塞方法，如 `take()` 和 `put()`，这些方法会在队列为空或满时阻塞调用线程，直到条件满足。
-   **超时机制**：部分方法支持超时参数，允许在指定时间内等待，如果条件未满足则抛出异常或返回特定值。


## 常见实现类

### **ArrayBlockingQueue**

-   **特点**：基于数组的有界阻塞队列，容量固定。
-   **适用场景**：适合需要固定大小的队列，且希望在队列满时阻塞生产者，在队列空时阻塞消费者。
-   **性能**：由于是基于数组实现，访问速度较快。

```java
BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);
```

### **LinkedBlockingQueue**

-   **特点**：基于链表的可选有界阻塞队列，默认无界（容量为 `Integer.MAX_VALUE`）。
-   **适用场景**：适合需要动态调整大小的队列，且希望在队列满时阻塞生产者，在队列空时阻塞消费者。
-   **性能**：基于链表实现，插入和删除操作的时间复杂度为 O(1)。

```java
BlockingQueue<String> queue = new LinkedBlockingQueue<>();
```

### **SynchronousQueue**

-   **特点**：不存储元素的阻塞队列，每个插入操作必须等待另一个线程的移除操作，反之亦然。
-   **适用场景**：适合直接传递数据的场景，例如生产者和消费者之间直接交换数据。
-   **性能**：非常轻量级，但不适合存储大量数据

```java
BlockingQueue<String> queue = new SynchronousQueue<>();
```

### **PriorityBlockingQueue**

-   **特点**：基于优先级堆的无界阻塞队列，元素按自然顺序或自定义比较器排序。
-   **适用场景**：适合需要按优先级处理任务的场景。
-   **性能**：插入和删除操作的时间复杂度为 O(log n)。

```java
BlockingQueue<String> queue = new PriorityBlockingQueue<>();
```

### **DelayQueue**

-   **特点**：元素只有在其延迟期满后才能被取出的无界阻塞队列。
-   **适用场景**：适合定时任务调度，例如任务在指定时间后执行。
-   **性能**：插入和删除操作的时间复杂度为 O(log n)。

```java
BlockingQueue<DelayedTask> queue = new DelayQueue<>();
```

#### **常用方法**

`BlockingQueue` 接口提供了多种方法来操作队列，包括阻塞、非阻塞和带超时的方法：

-   **阻塞方法**：
    -   `put(E e)`：将元素插入队列，如果队列已满，则阻塞直到有空间。
    -   `take()`：从队列中移除并返回头部元素，如果队列为空，则阻塞直到有元素。
-   **非阻塞方法**：
    -   `offer(E e)`：尝试将元素插入队列，如果成功返回 `true`，否则返回 `false`。
    -   `poll()`：尝试从队列中移除并返回头部元素，如果队列为空则返回 `null`。
-   **带超时的方法**：
    -   `offer(E e, long timeout, TimeUnit unit)`：尝试在指定时间内将元素插入队列，如果成功返回 `true`，否则返回 `false`。
    -   `poll(long timeout, TimeUnit unit)`：尝试在指定时间内从队列中移除并返回头部元素，如果成功返回元素，否则返回 `null`。

#### 实现生产者-消费者示例

```java
import java.util.concurrent.*;

public class BlockingQueueExample {
    public static void main(String[] args) throws InterruptedException {
        // 创建一个容量为 5 的阻塞队列
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);

        // 生产者线程
        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    String message = "Message " + i;
                    System.out.println("Producing: " + message);
                    queue.put(message); // 如果队列满了，会阻塞
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        // 消费者线程
        Thread consumer = new Thread(() -> {
            try {
                while (true) {
                    String message = queue.take(); // 如果队列为空，会阻塞
                    System.out.println("Consuming: " + message);
                    Thread.sleep(200);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        producer.start();
        consumer.start();

        // 等待一段时间后中断消费者线程
        Thread.sleep(3000);
        consumer.interrupt();
    }
}
```