# ArrayList 与 Vector 的区别

-   **数据结构相同**ArrayList 和 Vector它们的底层物理结构都是数组，我们称为**动态数组**。

-   **线程安全不同**
    -   ArrayList 是新版的动态数组，**线程不安全**，效率高
    -   Vector 是旧版的动态数组，**线程安全**，效率低。 
-   **动态数组的扩容机制不同**
    -   ArrayList 默认扩容为原来的 1.5 倍
    -   Vector 默认扩容增加为原来的 2 倍。
-   **数组的初始化容量不同**
    -   如果在构建 ArrayList 与 Vector 的集合对象时，没有显式指定初始化容量，那么 Vector 的内部数组的初始**容量默认为 10**，而 ArrayList 在 JDK 6.0 及之前的版本也是 **10**，JDK8.0 之后的版本 ArrayList 初始化为长度为 **0** 的空数组，之后在添加第一个元素时，再创建长度为 10 的数组。
    -   原因： 用的时候，再创建数组，避免浪费。因为很多方法的返回值是 ArrayList 类型，需要返回一个 ArrayList 的对象，例如：后期从数据库查询对象的方法，返回值很多就是 ArrayList。有可能你要查询的数据不存在，要么返回null，要么返回一个没有元素的 ArrayList 对象。 

|                          | Vector           | ArrayList                               |
| ------------------------ | ---------------- | --------------------------------------- |
| 版本                     | JDK1.0（最古老） | JDK1.2                                  |
| 线程安全                 | 安全             | 不安全                                  |
| 默认初始容量             | 10               | 0，首次添加元素后默认容量10（JDK8开始） |
| 是否支持手动指定初始容量 | 支持             | 支持                                    |
| 扩容                     | 2倍              | 1.5倍                                   |
| 是否支持手动指定增量     | 支持             | 不支持                                  |

补充说明

-   Vector无参构造器创建Vector对象时，直接创建长度为10的数组；ArrayList无参构造器创建ArrayList对象时，数组先初始化为`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`，首次add元素时才会创建长度为10的数组；
-   Vector扩容频率低，空间利用率低；ArrayList扩容频率高，空间利用率更高；

>   相关面试题
>
>   问：什么是Vector？它是List接口的实现类，是古老的动态数组
>
>   问：ArrayList默认大小是多少，是如何扩容的？
>
>   问：ArrayList是线程安全的吗？不是
>
>   问：ArrayList为什么不是线程安全的？ArrayList没有内置的同步机制来确保多线程环境下的操作安全。这意味着在多线程环境下使用ArrayList时，需要外部手动添加同步机制，如使用synchronized关键字或使用Collections.synchronizedList方法。
>
>   问：ArrayList初始化1万条数据，怎么优化？在new的使用指定初始化容量，避免频繁的扩容操作。