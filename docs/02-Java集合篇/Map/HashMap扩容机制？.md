# HashMap扩容机制？

`HashMap` 的扩容（rehashing）主要发生在以下两种情况下：

- **初始化情况**

**当添加元素时，如果当前数组为空，会进行初始化**：默认情况下，会创建一个长度为 16 的数组，并且加载因子（load factor）默认为 0.75。

- **元素数量大于或等于阈值情况**

**当数组中的元素数量大于或等于阈值（数组长度 * 加载因子）时**。例如，当数组长度为 16，加载因子为 0.75，并且元素数量达到 12 时（16 * 0.75 = 12），会触发扩容。扩容时，数组长度会翻倍（通常是扩容为2倍），并重新哈希所有元素到新的数组中。

## **扩容过程**

1、扩容的时候，默认会创建一个新数组，大小为老数组的2倍

2、`HashMap` 会**重新计算每个元素的哈希值**，并根据新的数组长度重新定位其索引位置

由于数组长度翻倍，哈希值的位运算结果可能会改变，导致元素在新数组中的位置与旧数组不同。（**JDK1.7及之前是这样子的**）

3、以我们正常人的思维来看，每一个元素都是重新hash一个个搬迁到新数组中的。

## JDK1.8优化数据的搬迁

JDK1.8开始做了优化，关键点就在于数据的长度是2的幂次方，且扩容时为原来的2倍。

举例：

因为数组的长度是2的幂次方，所以假设数组长度为16（二进制为01000），那么新数组的长度就为32（二进制为10000），它们之间的差别就在于高位多了1。

补充：`HashMap` 中是以key的hash值来定位到key存放在数组中的索引位置的（`(数组长度-1) & hash`）

```java
16-1=15 二进制为001111
32-1=31 二进制为011111
```

所以重点就在key的hash值从右往左数第五位是否是1：

- 如果是1说明需要搬迁到新位置，且新位置的下标就是 原下标+16（原数组大小）

- 如果是0说明吃不到新数组长度的高位，那就还是在原来的位置，不需要迁移。

所以，我们刚好拿老数组的长度（010000）来判断高位是否是 1，这里只有两种情况，要么是 1 要么是 0 。

![1724310284178](../assets/HashMap扩容机制.png)

从上面的源码可以看到，链表的数据是一次性计算完，然后一堆搬运的，因为扩容时候，节点的下标变化只会是原位置，或者原位置+老数组长度，不会有第三种选择。

上面的位操作，包括为什么是原下标+老数组长度等，如果你不理解的话，可以举几个数带进去算一算，就能理解了。

总结一下，**JDK1.8 的扩容不需要每个节点重新计算 hash 值**，而是通过和老数组长度的 & 计算是否为 0，来判断新下标的位置。