# 为什么不建议使用MQ实现订单到期关闭？

回顾一下利用MQ实现订单的到期（具体查看场景题篇）

-   kafka（MQ 方案不推荐，大量无效调度）
-   RocketMQ延迟消息（MQ 方案不推荐，大量无效调度）
-   RabbitMQ死信队列（MQ 方案不推荐，大量无效调度）
-   RabbitMQ插件（MQ 方案不推荐，大量无效调度）

但是，其实用MQ的延迟消息实现订单的到期关闭并不是一种特别好的方案，尤其是在数据量比较大的情况下。主要存在以下几个问题：

-   **资源占用与成本**：如果系统中存在大量订单，为每一个订单都创建一个延迟消息可能会导致消息队列中**积压大量的消息**，这不仅增加了消息队列的资源消耗，也可能导致增加成本，尤其是在使用云服务提供商的消息队列服务时。

-   **延迟消息的限制（重要）**：首先并不是所有的消息队列服务都支持延迟消息，即使有一些支持，也可能对消息的延迟时间有限制。
    -   例如，某些服务可能限制延迟时间的最大值，这可能无法满足所有订单的到期关闭需求。
    -   （尤其是一些B类采购订单，关闭时间可能会比较长）

-   **可靠性问题（重要）**：虽然消息队列一般来说可靠性较高，但是也没办法做到100%不丢消息，所以在极端情况下，会有丢消息的风险。

-   **精确性问题**：消息的投递延迟是比较常见的一种情况，这可能会导致订单关闭操作不够精确。

-   **大量无效消息（重要）**：使用MQ实现订单到期关闭，就要把订单放到MQ中，但是大部分订单会提前取消或者完成支付，这就会导致很多无效的消息。

-   **扩展性问题**：随着系统规模的扩大，依赖于消息队列的延迟消息来处理订单到期可能遇到扩展性问题。系统可能需要更复杂的消息队列管理策略和更高效的资源利用策略来应对不断增长的订单量。

这里尤其是**可靠性及无效消息的问题比较明显**，所以在一个订单量比较大的场景，不是特别建议用MQ实现订单的到期关闭。

一般是通过定时任务来实现，比如阿里内部就搞了个TOC（超时中心），就是基于定时任务来实现的订单到期关闭。
