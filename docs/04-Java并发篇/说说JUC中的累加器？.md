# 说说JUC中的累加器？

在Java中，累加器（Accumulator）一般指的是DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder这几个类。

累加器主要用于多线程环境下对共享变量的高效累加操作。传统的`AtomicLong`虽然通过CAS（Compare-And-Swap）实现无锁操作，但在高并发场景下，多个线程频繁修改同一变量会导致大量CAS失败重试，性能急剧下降。为此，JUC引入了`LongAdder`和`LongAccumulator`，通过数据分片和函数式操作优化性能。



**LongAdder**

-   设计思想：将单一的累加变量拆分为多个分片（`Cell`数组），每个线程优先操作不同的分片，减少竞争。最终总和通过合并所有分片的值（`sum()`方法）得到
-   关键实现：
    -   动态扩容：初始时仅使用`base`字段，当检测到竞争时，动态创建`Cell`数组，并按需扩容（长度限制为`NCPU`的2的幂次方）
    -   哈希优化：通过线程哈希值映射到不同分片，减少冲突
    -   避免伪共享：`Cell`类使用`@sun.misc.Contended`注解填充缓存行，防止多个变量共享同一缓存行导致的性能下降
-   适用场景：高并发统计场景（如计数器），但`sum()`方法的返回值可能不实时精确



**LongAccumulator**

-   设计思想：在`LongAdder`基础上进一步扩展，支持自定义累加函数（如累加、取最大值等），通过`LongBinaryOperator`接口实现
-   关键特性：
    -   函数式操作：允许用户定义累加规则（例如`Long::max`用于维护最大值）
    -   动态分片：与`LongAdder`类似，通过分片减少竞争
-   **适用场景**：需要复杂累加逻辑的场景（如统计极值或自定义聚合操作）



| 类名              | 实现方式            | 使用场景                     | 性能特点                   |
| ----------------- | ------------------- | ---------------------------- | -------------------------- |
| `AtomicLong`      | 单一变量+CAS        | 低并发精确计数               | 高竞争时性能下降明显       |
| `LongAdder`       | 分片累加+合并结果   | 高并发统计（非精确求和）     | 高并发下性能稳定，吞吐量高 |
| `LongAccumulator` | 分片累加+自定义函数 | 复杂累加逻辑（如最大值统计） | 灵活但需额外函数调用开销   |

**性能提升的核心原因**：

-   **减少竞争**：通过分片分散线程操作，降低CAS失败概率
-   **空间换时间**：牺牲内存空间（多个分片）换取并发性能
-   **缓存优化**：避免伪共享提升CPU缓存利用率


