# 线程池的shutDown和shutDownNow的区别

ExecutorService接口中，`shutdown()`和`shutdownNow()`都是用于关闭线程池的方法

## 口语化

`shutdown()`是一个比较“文明”的做法，它不再接收新任务，但会把已经提交的任务执行完，任务队列（的任务）不会漏掉，线程池状态会变成shutdown，
等线程池中所有任务执行完才会真正终止线程池。

:::tip
适用于程序平滑的关闭，优雅收场的场景。
:::

而`shutdownNow()`是“唬人”的方式硬来，一上来就想要**尝试中断**线程池中正在执行的任务，而队列中还未开始的任务通通会丢出来给你，
线程池状态会变成stop。

:::tip
适用于紧急关停的场景。
:::

需要注意的是，这里是**尝试中断**，`shutdownNow()`方法会调用`Thread.interrupt()`来中断任务，但是如果你的任务中没有检查`Thread.interrupted()`状态，
那么这一切都会是徒劳无功。

就像是尝试喊醒一个装睡的人，所以正在执行的任务，并不一定会被调停。




## **shutdown()**

`shutdown()`方法会启动线程池的关闭过程。

它会**停止接受新的任务提交**，但会继续执行已经提交的任务（包括正在执行的和已提交但尚未开始执行的任务（即队列中的任务））。

调用`shutdown()`后，线程池会进入一个**平滑的关闭**过程，等待所有已提交的任务完成后才会完全终止

## **shutdownNow()**

`shutdownNow()`方法会**尝试停止（中断）所有正在执行的任务**，并返回一个包含尚未开始执行的任务的列表。

它会立即停止接收新的任务，并试图中断正在执行的任务。

调用`shutdownNow()`后，线程池**会尽快停止所有正在执行的任务**（即它会尽力的**中断**任务），并返回尚未开始执行的任务列表。

需要注意的是，**无法保证所有正在执行的任务都能被中断**。

:::tip
关于无法保证所有正在执行的任务都能被中断

因为`shutdownNow()`方法是通过`Thread.interrupt()`来中断任务，如果任务中没有检查中断信号，那么任务无法被中断
:::

## 对比

| 特性                   | `shutdown()`                   | `shutdownNow()`                                              |
| :--------------------- | :----------------------------- | :----------------------------------------------------------- |
| **停止接收新任务**     | 是                             | 是                                                           |
| **等待现有任务完成**   | 是（包括正在执行和排队的任务） | 否（尝试中断正在执行的任务）                                 |
| **中断正在执行的任务** | 否                             | 是（通过 `interrupt()` 方法）<br>具体的中断效果取决于任务对中断信号的响应 |
| **返回未执行任务**     | 否                             | 是（返回尚未开始的任务列表）                                 |
| **关闭速度**           | 较慢（等待所有任务完成）       | 较快（立即尝试关闭）                                         |

##  总结

`shutdown()`是平滑的关闭线程池，`shutdownNow()`是立即关闭线程池，具体的关闭与否需要看任务是否配合
