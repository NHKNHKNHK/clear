# Java创建线程的几种方式有什么区别？

## **继承Thread类**

-   实现方式：通过继承 `java.lang.Thread` 类并重写 `run()` 方法。

-   特点：
    -   简单直接，适合简单的场景。
    -   **受限于 Java 的单继承机制**，如果类已经继承了其他类，则不能使用这种方式。
    -   **不支持返回值**：任务执行完毕后无法返回结果。

-   适用场景：非常基础的并发需求，代码量较少且不需要复杂功能。不适合复杂的线程管理和资源共享场景

## **实现Runnable接口**

-   实现方式：通过实现 `java.lang.Runnable` 接口并重写 `run()` 方法，然后将 Runnable 实例传递给 Thread 类的构造函数。
-   特点：
    -   **避免了单继承限制**，灵活性更高（因为类可以实现多个接口）。
    -   **资源共享**：多个线程可以共享同一个 Runnable 实例，便于资源共享。
    -   **不支持返回值**：任务执行完毕后无法返回结果
-   适用场景：大多数并发编程场景，尤其是需要多个线程执行相同任务时。

## **实现Callable接口和使用FutureTask**

-   实现方式：通过实现 `java.util.concurrent.Callable` 接口并重写 `call()` 方法。与 Runnable 不同，Callable **可以返回结果**并且**可以抛出异常**。但实现和使用稍微复杂一些。

-   特点：
    -   **支持返回值和异常处理**，适用于需要返回结果的任务。
    -   通常与 Future 和 ExecutorService 一起使用，便于管理和获取任务结果。（使用FutureTask来管理和返回结果）

-   适用场景：需要任务返回结果或处理异常的场景。

## **使用线程池**

-   实现方式：通过 `java.util.concurrent.ExecutorService` 来管理线程的创建和执行。ExecutorService 提供了线程池管理功能，如固定大小的线程池、缓存线程池、定时线程池等。

-   特点
    -   **线程池管理**：通过线程池复用线程，减少频繁创建和销毁线程的开销。
    -   **任务调度**：支持异步任务提交和结果获取。
    -   **灵活配置**：可以根据任务量动态调整线程池大小。可以根据需求选择不同类型的线程池（如固定大小、缓存、定时等）。
    -   **简化开发**：隐藏了线程管理的复杂性，使代码更加简洁和易于维护。

-   适用场景：需要高效管理和复用线程的场景，特别是高并发环境。

