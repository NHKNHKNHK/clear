# 为什么启动线程不直接调用run()，而调用start()？

想要启动多线程，**必须调用`start()`方法**。

**一个线程对象只能调用一次start()方法**启动线程，如果重复调用会抛出`IllegalThreadStateException`异常

## **start()方法**

start()方法的作用是**启动一个新线程**，并且使该线程进入**就绪状态**，等待操作系统的线程调度器来调度它执行。

当你调用start()方法时，Java虚拟机会创建一个新的执行线程。在这个新的线程中，Java虚拟机会自动调用run()方法。

调用start()方法后，原来的线程和新创建的线程可以并发执行

## **run()方法**

run()方法包含了线程执行的代码，是你需要在新线程中执行的任务。

如果直接调用run()方法，run()方法会在当前线程中执行，而不会启动一个新线程。（失去了创建线程的意义）

直接调用run()方法不会创建新的线程，所有代码在调用run()方法的线程中顺序执行



## **为什么不能直接调用run()方法**

1.  **启动新线程**：start()方法负责启动一个新线程，而直接调用run()只是普通的方法调用，不会启动新线程。
2.  **并发执行**：通过start()方法启动的新线程可以与原来的线程并发执行，而直接调用run()方法则是在当前线程中顺序执行。
3.  **线程状态管理**：start()方法会使线程进入就绪状态，等待操作系统调度，而直接调用run()方法不会改变线程的状态管理



-   如果自己手动调用run()方法，那么就只是普通方法，不会启动新线程。
-   run()方法由JVM调用，什么时候调用，执行的过程控制都由操作系统的CPU调度决定。
-   我们创建线程的目的是为了更充分地利用CPU资源，如果直接调用run()方法，就失去了创建线程的意义
-   start()方法是Java线程中约定的内置方法，能够确保代码在新的线程上下文中执行
-   start()方法包含了除创建新线程的特殊代码逻辑。run()方法是我们自己写的代码，显然没有这个能力
-   想要启动多线程，**必须调用start方法**。
-   **一个线程对象只能调用一次start()方法**启动线程，如果重复调用了，则将抛出以上的异常`IllegalThreadStateException`。
