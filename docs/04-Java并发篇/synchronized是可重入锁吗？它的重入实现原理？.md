# synchronized是可重入锁吗？它的重入实现原理？

**是的，synchronized 默认情况下是可重入锁**。这意味着如果一个线程已经持有了某个对象的锁，那么它可以在不释放这个锁的情况下再次获取该锁，而不会导致死锁

**重入实现原理**

-   **对象头中的锁信息**：
    -   在 Java 中，每个对象都有一个对象头（Object Header），其中包含了一部分用于同步的信息，比如锁状态、线程ID等。
-   **Monitor机制**：
    -   `synchronized` 的底层实现依赖于 JVM 内部的数据结构——Monitor（监视器）。Monitor中有一个计数器，用来记录当前持有锁的次数，以及一个指向持有锁的线程的引用。
-   **锁获取流程**：
    -   当一个线程尝试进入由 `synchronized` 保护的方法或代码块时，它会检查 Monitor 中的线程引用是否为 null 或者是否与自己相同。
    -   如果是第一次获取锁，Monitor 记录下当前线程，并将计数器设为1；如果是同一个线程再次获取锁，则计数器加1。
    -   线程每次退出 `synchronized` 代码块时，计数器减1，当计数器归零时，表示该线程完全释放了锁，其他等待的线程可以尝试获取锁。
-   **字节码指令**：
    -   在编译后的字节码中，`synchronized` 关键字会被转换成 `monitorenter` 和 `monitorexit` 指令，分别对应获取和释放锁的操作。
-   **优化措施**：
    -   JVM 对 `synchronized` 进行了许多优化，如偏向锁、轻量级锁和重量级锁的状态转换，以提高性能。这些优化使得在大多数情况下，`synchronized` 的性能非常接近显式锁（如 `ReentrantLock`），并且在某些场景下甚至更优

>   **每个锁对象拥有一个锁计数器和一个指向持有锁的线程的指针**。
>
>   
>
>   当指向 `monitorenter` 时，如果目标锁对象的计数器为0，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器+1。
>
>   在目标锁对象的计数器不为0的情况下，如果锁对象的持有线程是当前线程，那么Java虚拟机可以将其计数器+1，否则需要等待，直至持有线程释放该锁。
>
>   当执行`monitorexit` 时，Java虚拟机则需将锁对象的计数器-1。计数器为0代表锁已被释放。
