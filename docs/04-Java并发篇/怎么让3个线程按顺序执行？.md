# 怎么让3个线程按顺序执行？

-   使用join方法
-   使用CountDownLatch
-   使用CyclicBarrier
-   单个线程的线程池

>   **Java中如何控制多个线程的执行顺序？**
>
>   CompletableFuture，例如thenRun，假设t1、t2、t3任务要按顺序执行，就可以使用thenRun方法
>
>   synchronized + wait/notify，通过对象锁和线程间通信机制来控制线程的执行顺序
>
>   ReentrantLock + condition
>
>   Thread类的join方法，通过调用这个方法，可以使得一个线程等待另一个线程执行完毕后再继续执行
>
>   CountDownLatch，使一个或线程等待其他线程完成各自工作后再继续执行
>
>   CyclicBarrier，是多个线程互相等待，直到所有线程都到达某个共同点后再继续执行
>
>   Semaphore，控制线程的执行顺序，适用于需要限制同时访问资源的线程数量的场景
>
>   线程池，单个线程的线程池，按序的将任务提交到线程池即可
>
>   

## **方式一：使用join方法**

原理：

-   `join` 方法可以让当前线程等待另一个线程执行完毕后再继续执行。
-   通过依次调用线程的 `join` 方法，可以确保线程按顺序执行

```java
public class Main {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 is running");
        });
        Thread t2 = new Thread(() -> {
            try {
                t1.join(); // 等待t1线程执行完毕
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 2 is running");
        });
        Thread t3 = new Thread(() -> {
            try {
                t2.join(); // 等待t2线程执行完毕
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 3 is running");
        });

        t1.start();
        t2.start();
        t3.start();
    }
}
```

## **方式二：使用CountDownLatch**

原理：

-   `CountDownLatch` 是一个同步工具类，允许一个或多个线程等待其他线程完成操作。
-   初始化时设置计数器值，每个线程完成任务后调用 `countDown` 减少计数器，当计数器为 0 时，等待的线程被唤醒。

```java
public class Main {
    public static void main(String[] args) {
        CountDownLatch latch1 = new CountDownLatch(1);
        CountDownLatch latch2 = new CountDownLatch(1);

        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 is running");
            latch1.countDown(); // 线程t1执行完毕，计数器减1，通知t2线程开始执行
        });
        Thread t2 = new Thread(() -> {
            try {
                latch1.await(); // 等待t1线程执行完毕
                System.out.println("Thread 2 is running");
                latch2.countDown(); // 线程t2执行完毕，计数器减1，通知t3线程开始执行
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        Thread t3 = new Thread(() -> {
            try {
                latch2.await(); // 等待t2线程执行完毕
                System.out.println("Thread 3 is running");
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        t1.start();
        t2.start();
        t3.start();
    }
}
```

## **方式三：使用CyclicBarrier**

-   `CyclicBarrier` 是一个同步工具类，允许多个线程在某个屏障点（barrier point）相互等待。
-   初始化时设置参与线程的数量，所有线程到达屏障点后才能继续执行

```java
public class Main {
    public static void main(String[] args) {
        CyclicBarrier barrier1 = new CyclicBarrier(2);
        CyclicBarrier barrier2 = new CyclicBarrier(2);

        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 is running");
            try {
                barrier1.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        });
        Thread t2 = new Thread(() -> {
            try {
                barrier1.await();
                System.out.println("Thread 2 is running");
                barrier2.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        });
        Thread t3 = new Thread(() -> {
            try {
                barrier2.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Thread 3 is running");
        });

        t1.start();
        t2.start();
        t3.start();
    }
}
```

