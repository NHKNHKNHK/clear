# 怎么让3个线程按顺序执行？

如果想要让三个线程依次执行，并且严格按照t1、t2、t3的顺序的话，主要就是想办法让三个线程之间可以通信、或者可以排队。

想让多个线程之间可以通信，可以通过join方法实现，还可以通过CountDownLatch、CyclicBarrier和Semaphore来实现通信。

想要让线程之间排队的话，可以通过线程池或者CompletableFuture的方式来实现

## Java中如何控制多个线程的执行顺序

- 使用join方法，通过调用这个方法，可以使得一个线程等待另一个线程执行完毕后再继续执行
- synchronized + wait/notify，通过对象锁和线程间通信机制来控制线程的执行顺序
- 使用CountDownLatch，使一个或线程等待其他线程完成各自工作后再继续执行
- 线程池，单个线程的线程池，按序的将任务提交到线程池即可
- CompletableFuture，例如thenRun，假设t1、t2、t3任务要按顺序执行，就可以使用thenRun方法
- 使用CyclicBarrier，是多个线程互相等待，直到所有线程都到达某个共同点后再继续执行
- ReentrantLock + condition
- Semaphore，控制线程的执行顺序，适用于需要限制同时访问资源的线程数量的场景

## 使用join方法

原理：

- `join` 方法可以让当前线程等待另一个线程执行完毕后再继续执行。
- 通过依次调用线程的 `join` 方法，可以确保线程按顺序执行

```java
public class Main {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 is running");
        });
        Thread t2 = new Thread(() -> {
            try {
                t1.join(); // 等待t1线程执行完毕
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 2 is running");
        });
        Thread t3 = new Thread(() -> {
            try {
                t2.join(); // 等待t2线程执行完毕
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 3 is running");
        });

        t1.start();
        t2.start();
        t3.start();
    }
}
```

## 使用CountDownLatch

原理：

- `CountDownLatch` 是一个同步工具类，允许一个或多个线程等待其他线程完成操作。
- 初始化时设置计数器值，每个线程完成任务后调用 `countDown` 减少计数器，当计数器为 0 时，等待的线程被唤醒。

```java
public class Main {
    public static void main(String[] args) {
        CountDownLatch latch1 = new CountDownLatch(1);
        CountDownLatch latch2 = new CountDownLatch(1);

        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 is running");
            latch1.countDown(); // 线程t1执行完毕，计数器减1，通知t2线程开始执行
        });
        Thread t2 = new Thread(() -> {
            try {
                latch1.await(); // 等待t1线程执行完毕
                System.out.println("Thread 2 is running");
                latch2.countDown(); // 线程t2执行完毕，计数器减1，通知t3线程开始执行
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        Thread t3 = new Thread(() -> {
            try {
                latch2.await(); // 等待t2线程执行完毕
                System.out.println("Thread 3 is running");
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        t1.start();
        t2.start();
        t3.start();
    }
}
```

## 使用CyclicBarrier

- `CyclicBarrier` 是一个同步工具类，允许多个线程在某个屏障点（barrier point）相互等待。
- 初始化时设置参与线程的数量，所有线程到达屏障点后才能继续执行

```java
public class Main {
    public static void main(String[] args) {
        CyclicBarrier barrier1 = new CyclicBarrier(2);
        CyclicBarrier barrier2 = new CyclicBarrier(2);

        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 is running");
            try {
                barrier1.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        });
        Thread t2 = new Thread(() -> {
            try {
                barrier1.await();
                System.out.println("Thread 2 is running");
                barrier2.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        });
        Thread t3 = new Thread(() -> {
            try {
                barrier2.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Thread 3 is running");
        });

        t1.start();
        t2.start();
        t3.start();
    }
}
```

- `CyclicBarrier` 是可以复用的，如下就只使用了一个CyclicBarrier对象

```java
public class Main {
    public static void main(String[] args) throws BrokenBarrierException, InterruptedException {
        CyclicBarrier barrier1 = new CyclicBarrier(2);

        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 is running");
            try {
                barrier1.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        });
        Thread t2 = new Thread(() -> {
            System.out.println("Thread 2 is running");
            try {
                barrier1.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        });
        Thread t3 = new Thread(() -> {
            System.out.println("Thread 3 is running");
            try {
                barrier1.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        });

        t1.start();
        // 等待t1线程执行完毕
        barrier1.await();

        t2.start();
        // 等待t2线程执行完毕
        barrier1.await();

        t3.start();
        // 等待t3线程执行完毕
        barrier1.await();
    }
}
```

## 使用Semaphore

- `Semaphore` 是一个同步工具类，核心作用是 **控制同时访问特定资源的线程数量**
- 当控制线程semaphore的许可证数量为1时，则同一时间只能有一个线程访问该资源，就可以实现让3个线程按顺序执行的效果。

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Semaphore semaphore = new Semaphore(1);

        Thread t1 = new Thread(() -> {
            try {
                System.out.println("Thread 1 is running");
            } finally {
                // 释放许可证，表示完成一个线程
                semaphore.release();
            }
        });

        Thread t2 = new Thread(() -> {
            try {
                System.out.println("Thread 2 is running");
            } finally {
                // 释放许可证，表示完成一个线程
                semaphore.release();
            }
        });

        Thread t3 = new Thread(() -> {
            try {
                System.out.println("Thread 3 is running");
            } finally {
                // 释放许可证，表示完成一个线程
                semaphore.release();
            }
        });

        // 等待线程t1执行完
        semaphore.acquire();
        t1.start();

        // 等待线程t2执行完
        semaphore.acquire();
        t2.start();

        // 等待线程t3执行完
        semaphore.acquire();
        t3.start();
    }
}
```

## CompletableFuture

原理：

- `thenRun`：任务A执行完毕执行B，并且B不需要A的结果

例如`thenRun`，假设t1、t2、t3任务要按顺序执行，就可以使用`thenRun`方法，然后使用``join`等待所有任务完成。

```java
public class Main {
    public static void main(String[] args) {

        CompletableFuture<Void> future1 = CompletableFuture.runAsync(() -> {
            System.out.println("Thread 1 is running");
        });

        // 等待线程t1完成
        future1.join();

        CompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {
            System.out.println("Thread 1 is running");
        });

        // 等待线程t2完成
        future2.join();

        CompletableFuture<Void> future3 = CompletableFuture.runAsync(() -> {
            System.out.println("Thread 1 is running");
        });

        // 等待线程t3完成
        future3.join();
    }
}
```

上面的代码还可以做一些优化：

```java
public class Main {
    public static void main(String[] args) {

        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
            System.out.println("Thread 1 is running");
        }).thenRun(
            () -> System.out.println("Thread 2 is running")
        ).thenRun(
            () -> System.out.println("Thread 3 is running")
        );

        future.get();
    }
}
```
