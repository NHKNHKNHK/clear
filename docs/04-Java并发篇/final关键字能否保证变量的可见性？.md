# final关键字能否保证变量的可见性？

不可以。

你可能看到有些观点说final能够保证可见性，那不是我们常说的可见性，下面探讨一下我们所说的可见性。

一般而言，我们指的**可见性是一个线程修改了共享变量，其他线程能够立马感知到修改，得到最新修改的值**。

这样子一说，我们很容易的可以联想到 `volatile` 关键字可以保证这种可见性。

而 **final** 并不能保证其他线程能够立刻感知到变量的修改，他**只能够保证final修饰的变量在构造器正确执行之后初始值对其他线程的可见性。**



有些观点说 final 能够保证可见性，指的是 final 修饰的字段在构造器初始化完成，并且期间没有把 this 传递出去（即 没有this逸出），那么当构造器执行完毕之后，其他线程就能够看到 final 字段的初始值。

如果不用 final 修饰的话，那么有可能在构造器中对字段的写操作会被重排序到外面，这样别的线程就拿不到写操作之后的值了（可能会获取到未完全初始化的值）。

>   **final关键字的可见性保证**
>
>   -   **对象正确构造时的可见性**‌
>
>       当一个对象被正确构造（无`this`引用逸出）且其`final`字段在构造器中完成初始化后，其他线程访问该对象时，能确保看到`final`字段的初始值。这是由Java内存模型（JMM）的特殊规则保证的：
>       -   ‌**禁止重排序**‌：JVM会确保`final`字段的初始化操作不会被重排序到构造器之外，从而避免其他线程看到未完全初始化的值。
>       -   ‌**安全发布**‌：只要对象引用未在构造过程中逸出，`final`字段的值在对象发布到其他线程时一定是构造器完成后的值。



对于 final 域，编译器和处理器要遵守两个重排序规则

-   1、在构造器内对一个final 域写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。（这样可以保证 final 域在对象被其他线程可见前，已经被正确初始化了）

-   2、当一个线程首次读取某个对象的引用时，不能与随后读取该对象的 final 域的操作重排序。（这确保了当一个线程看到对象引用时，也能正确读取 final 域的值，而不会拿到过期数据）

所以，这才是 fianl 的可见性，此可见性并非并发编程中谈到的可见性。



| 机制             | 保证可见性范围                                               | 适用场景                   |
| ---------------- | ------------------------------------------------------------ | -------------------------- |
| ‌**final**‌        | **仅限构造器初始化的值**，<br>对于可变类型，例如集合，final仅保证了引用本身的可见性，其内部状态的修改仍需要进行同步以确保并发下的可见性。 | 不可变字段的线程安全发布   |
| ‌**volatile**‌     | 变量修改的即时可见性                                         | 多线程共享变量的实时同步   |
| ‌**synchronized**‌ | 代码块内的可见性及原子性                                     | 复杂操作的互斥与状态一致性 |



**final 总结**

-   **避免this逸出**‌：确保对象构造完成后再发布引用。
-   **优先使用final**‌：对于不可变字段，用`final`简化线程安全设计。

-   **不可变对象**‌：若字段引用的对象本身不可变（如`String`或`Integer`），`final`可彻底保证线程安全。

-   ‌**正确构造时**‌：`final`字段的初始值对其他线程可见，无需额外同步。
-   ‌**失效条件**‌：构造过程中`this`逸出或字段引用可变对象内部状态。
-   ‌**适用性**‌：适合不可变数据的线程安全发布，但需注意引用对象的可变性。
