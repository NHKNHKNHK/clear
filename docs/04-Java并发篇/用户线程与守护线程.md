# 用户线程与守护线程

Java中线程分为用户线程和守护线程

## **用户线程**

用户线程是应用程序创建的普通线程，也称为非守护线程。当所有用户线程都结束时，Java 虚拟机 (JVM) 也会退出。

一般情况下不做特别说明配置，**默认都是用户线程**

用户线程是系统的**工作线程**，它会完成这个程序需要完成的业务操作。

**特点**

-   **生命周期**：用户线程的生命周期由应用程序控制。只要有一个用户线程在运行，JVM 就会继续运行。

- **重要性**：用户线程通常用于执行应用程序的主要任务，例如处理业务逻辑、执行计算等。

-   **关闭 JVM**：JVM 只有在所有用户线程都结束后才会退出，即使还有守护线程在运行。

**使用场景**

-   适用于需要执行重要任务且不能中途被终止的线程。例如：处理用户请求的线程，执行关键业务逻辑的线程

## **守护线程 (Daemon Thread)**

守护线程是**为其他线程提供服务和支持**的一种特殊的线程。当所有非守护线程（用户线程）都结束时，JVM 会自动退出，即使守护线程还在运行。

比如：垃圾回收线程

守护线程作为一个服务线程，没有服务对象时就没有必要继续运行了，如果用户线程全部结束了，就意味着程序需要完成的业务操作已经结束了，系统就可以退出了。

所有当系统只剩下守护进程时，JVM会自动退出。

**特点**

-   **生命周期**：守护线程的生命周期依赖于用户线程。当所有用户线程结束时，守护线程也会自动终止。

-   **后台任务**：守护线程通常用于执行后台任务，如垃圾回收、日志记录等。

-   **低优先级**：守护线程通常优先级较低，因为它们主要为用户线程提供支持。

**使用场景**

-   适用于执行后台任务或辅助任务的线程，这些任务不需要在 JVM 退出时完成。例如：JVM 的垃圾回收线程，日志记录线程，监控和统计线程

示例

```java
public class ThreadExample {
    public static void main(String[] args) {
        Thread userThread = new Thread(() -> {
            try {
                Thread.sleep(5000);
                System.out.println("User thread finished");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread daemonThread = new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(1000);
                    System.out.println("Daemon thread running");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        daemonThread.setDaemon(true);

        userThread.start();
        daemonThread.start();

        System.out.println("Main thread finished");
    }
}
```

在这个例子中：

userThread是一个用户线程，它会运行 5 秒钟。daemonThread是一个守护线程，它会每秒钟打印一次消息。

当userThread结束后，JVM 会退出，即使daemonThread还在运行

## 扩展

### setDaemon

- `setDaemon(boolean on)`方法必须在`start()`方法之前调用，否则抛出 `IllegalThreadStateException`异常

- 因为我们的线程已经启动了，然后再将常规线程设置为守护进程，这一操作线程是不符合逻辑

```java
/**
     * Marks this thread as either a {@linkplain #isDaemon daemon} thread
     * or a user thread. The Java Virtual Machine exits when the only
     * threads running are all daemon threads.
     *
     * <p> This method must be invoked before the thread is started.
     *
     * @param  on
     *         if {@code true}, marks this thread as a daemon thread
     *
     * @throws  IllegalThreadStateException
     *          if this thread is {@linkplain #isAlive alive}
     *
     * @throws  SecurityException
     *          if {@link #checkAccess} determines that the current
     *          thread cannot modify this thread
     */
public final void setDaemon(boolean on) {
    checkAccess();
    if (isAlive()) {
        throw new IllegalThreadStateException();
    }
    daemon = on;
}
```
