# Java中的synchronized是怎么实现的？（底层原理）

synchronized关键字的实现是基于监视器锁（Monitor）。监视器锁是一个互斥锁，确保同一时间只有一个线程可以持有锁并执行同步代码块或方法。

每个Java对象都有一个对象头，其中包含对象的元数据信息，包括锁信息。对象头中的锁状态可以是无锁状态、偏向锁、轻量级锁和重量级锁。

在Java中，synchronized关键字的锁状态会根据竞争情况动态转换，主要包括以下几种状态：

-   **无锁状态**：没有线程竞争锁
-   **偏向锁**：当一个线程访问同步块时，JVM会将锁偏向该线程，减少锁的开销
    -   因为不存在竞争关系，所以将锁资源偏向某一线程，该线程再次进入时，无锁
-   **轻量级锁**（有一种说法也叫自旋锁）：当多个线程竞争锁时，JVM会尝试使用**自旋锁**，避免线程上下文切换的开销
    -   在线程阻塞之前会进行自旋尝试获取锁，如果其他线程释放锁，可能能够抢到锁资源
-   **重量级锁**：当自旋锁失败时，JVM会将锁升级为重要级锁，使用操作系统提供的互斥锁



>   扩展
>
>   锁消除/锁膨胀：这是编译器层面的优化
>
>   锁消除：编译时发现你锁的地方不存在竞争，会消除锁
>
>   锁膨胀：表示的是你控制的锁粒度太小了，导致频繁的加锁、释放锁，频繁的竞争资源，编译器会将锁的范围扩大
