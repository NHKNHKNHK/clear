## MySQL事务的四大特性？

**口语化表述**

MySQL事务的四大特性就是ACID，分别是原子性、一致性、隔离性、持久性。其中原子性就是确保事务中的所有操作要么全部成功，要么全部失败；一致性是指数据库从一个一致性的状态转换到另外一个一致性的状态；隔离性确保并发执行的事务彼此隔离开来，避免相互干扰；持久性确保事务一旦提交，其结果是永久性的。

-   **1、原子性（Atomicity）**

原子性确保事务中的所有操作要么全部完成，要么全部不完成。事务是一个不可分割的最小工作单元。

**例子**：假设有一个银行转账操作，事务包括从账户A中扣钱和向账户B中加钱。如果任何一个操作失败，整个事务都会回滚，账户A和账户B的余额不会发生变化。

-   **2、一致性（Consistency）**

一致性确保事务在完成后，数据库从一个一致状态转换到另一个一致状态。事务开始前和结束后，数据库的完整性约束没有被破坏。

**例子**：在银行转账操作中，一致性确保转账后总金额保持不变。如果账户A减少了100元，账户B就应该增加100元。

-   **3、隔离性（Isolation）**

隔离性确保并发执行的事务彼此隔离开来，避免相互干扰。不同的事务之间的操作是互不可见的，直到事务提交。

**隔离级别**：

1.  **读未提交（Read Uncommitted）**：一个事务可以读到另一个未提交事务的数据，可能导致脏读。
2.  **读已提交（Read Committed）**：一个事务只能读到已提交事务的数据，避免脏读。
3.  **可重复读（Repeatable Read）**：一个事务在整个过程中看到的数据是一致的，避免不可重复读。
4.  **串行化（Serializable）**：最高隔离级别，事务完全串行化执行，避免幻读。

-   **4、持久性（Durability）**

持久性确保事务一旦提交，其结果是永久性的，即使系统发生故障，数据也不会丢失。

**例子**：在银行转账操作中，一旦事务提交，转账操作的结果（账户A和账户B的余额变化）将永久保存在数据库中，即使之后系统崩溃，数据也不会丢失。



## MySQL在的事务隔离级别？

MySQL 主要支持四种事务隔离级别，分别是读未提交、读已提交、可重复读和串行化。

简单来说，读未提交就是一个事务可以读取另一个未提交事务的数据，可能导致脏读，即一个事务读取了另一个事务未提交的数据。如果该事务回滚，那么读到的数据将是无效的。

读已提交是说一个事务只能读取已经提交的事务的数据。这样可以避免脏读，但可能会出现不可重复读，即A事务读取完数据后B事务提交数据，A事务再次读取的数据和上次不相同

可重复读是说一个事务在整个过程中多次读取同一行数据时，结果是相同的。可以避免脏读和不可重复读，但可能会出现幻读。

串行化，这种级别下，事务完全串行化执行，避免了脏读、不可重复读和幻读。代价是并发性大大降低，事务可能会因为锁等待而阻塞。

1、读未提交（**READ UNCOMMITTED**）

-   允许事务读取其他事务尚未提交的数据。
-   这种情况下可能会发生“脏读”（Dirty Reads），即一个事务可以读取到另一个事务中未提交的数据。
-   是四种隔离级别中并发性能最好的，但数据安全性最差。

```mysql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

补充：

​	**脏读**：一个事务读取了另一个事务未提交的数据。如果该事务回滚，那么读到的数据将是无效的。

2、读已提交（**READ COMMITTED** ）

-   一个事务只能读取已经提交的数据。
-   避免了脏读的发生，但仍然可能出现“不可重复读”（Non-Repeatable Reads）和“幻读”（Phantom Reads）。
-   每次查询都会读取最新的已提交数据。

```mysql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

补充：

​	**不可重复读**：一个事务在读取同一行数据时，可能因为另一个事务的提交而得到不同的结果。

3、可重复读（**REPEATABLE READ** ）

-   MySQL **InnoDB 默认的隔离级别**。
-   在同一个事务中的多次查询返回相同的结果集，即使在这期间有其他事务对数据进行了修改并提交。
-   能够防止脏读和不可重复读，但仍然可能出现幻读。
-   InnoDB 存储引擎通过多版本并发控制（MVCC）来实现这一级别。

```mysql 
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

补充：

​	**幻读**：一个事务在读取某个范围内的行时，另一个事务在该范围内插入了新的行，导致前一个事务再次读取时发现了“幻影”行

4、串行化（**SERIALIZABLE** ）

-   最高的隔离级别。
-   事务被强制按顺序执行，完全避免了并发操作带来的问题，如脏读、不可重复读和幻读。
-   但是，这种隔离级别可能会导致大量的锁定，从而降低了系统的并发性能。

```mysql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

设置 MySQL 事务隔离级别的示例：

```
-- 设置全局事务隔离级别为可重复读SETGLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- 设置当前会话的事务隔离级别为读已提交SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- 开始事务START TRANSACTION;
-- 在事务内进行操作SELECT*FROM accounts WHERE account_id ='A';
-- 提交事务COMMIT;
```

小结：

​	每种隔离级别都有其优缺点，选择合适的隔离级别取决于应用程序的具体需求。例如，对于那些需要高并发的应用程序，可能更倾向于使用 `READ COMMITTED` 或 `REPEATABLE READ`，而对于那些对数据一致性要求极高的应用，则可能选择 `SERIALIZABLE`。

​	选择合适的隔离级别需要权衡数据一致性和系统性能之间的关系。对于大多数应用，默认的可重复读隔离级别已经能够提供足够的数据一致性和并发性能。

| **隔离级别**                | **脏读** | **不可重复读** | **幻读** |
| --------------------------- | -------- | -------------- | -------- |
| Read uncommitted (读未提交) | 存在     | 存在           | 存在     |
| Read committed (读已提交)   | ×        | 存在           | 存在     |
| Repeatable read (可重复读)  | ×        | ×              | 存在     |
| Serializable (串行化)       | ×        | ×              | ×        |



## 什么是脏读、幻读、不可重复读？

### **脏读**

脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

例如：张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。

### **不可重复读**

是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。

例如：在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。与此同时，事务B把张三的工资改为8000，并提交了事务。随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。

### **幻读**

是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

例如：目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。

### 不可重复读和幻读有什么区别

不可重复读的重点是修改：同样的条件，你读取过的数据，再次读取出来发现值不一样了

幻读的重点在于新增或者删除：同样的条件，第 1 次和第 2 次读出来的记录数不一样。





## 简述一条SQL在MySQL中的执行过程？



## MySQL的存储引擎有哪些？有什么区别？



## MySQL中InnoDB和MyISAM的区别？

-   **事务支持**：
    -   MyISAM 不支持事务，无法进行回滚和提交操作；
    -   InnoDB 支持**事务**，提供 ACID 特性（原子性、一致性、隔离性、持久性）。

-   **锁机制**：
    -   MyISAM 使用表级锁，每次操作都会锁定整个表，适合读多写少的应用；
    -   InnoDB 使用**行级锁**，每次操作只锁定相关的行，适合高并发和写操作频繁的应用。

-   **外键支持**：
    -   MyISAM 不支持外键，无法在表间建立引用完整性约束；
    -   InnoDB **支持外键**，可以在表间建立引用完整性约束，保证数据的一致性和完整性。

-   **全文索引**：
    -   MyISAM 原生支持全文索引，适合需要全文搜索的应用；
    -   InnoDB 从 **MySQL 5.6 开始支持全文索引**，但性能和功能上仍不如 MyISAM。

-   **数据存储结构**：
    -   MyISAM 将数据存储在三个文件中（`.frm`文件存储表结构，`.MYD`文件存储数据，`.MYI`文件存储索引）；
    -   InnoDB 将**数据和索引**存储在表空间文件（`.idb`文件）中，支持自动扩展和多表空间。

-   **崩溃恢复**：
    -   MyISAM 只支持基于表的崩溃恢复，恢复过程较慢且不完全；
    -   InnoDB 支持**自动崩溃恢复**，通过重做日志和回滚日志实现快速和完整的恢复。

-   **性能特点**：
    -   MyISAM 在读多写少场景下性能优越，查询速度快，占用资源少；
    -   InnoDB 在高并发和事务密集型场景下性能优越，写操作和并发处理能力强。

-   **存储空间**：
    -   MyISAM 存储空间效率较高，数据文件较小；
    -   InnoDB 可能占用更多存储空间，特别是需要存储事务日志和外键约束信息。

-   **表的大小限制**：
    -   MyISAM 受文件系统限制，单个表最大可达 256TB（取决于文件系统）；
    -   InnoDB 最大表大小可达 64TB，适合处理大规模数据集。

-   **适用场景**：
    -   MyISAM 适用于读多写少的场景，如数据仓库、日志分析等；
    -   InnoDB 适用于事务密集型和高并发场景，如在线交易系统、社交网络等。



## 存储引擎应该如何选择？

选择 MySQL 的存储引擎时，应根据具体应用场景、性能需求、数据完整性要求等因素进行综合考虑。

1.  **事务支持**：InnoDB 支持事务和 ACID 特性，适合需要事务支持的应用；MyISAM 不支持事务，适合对数据完整性要求不高的应用。
2.  **锁机制**：InnoDB 使用行级锁，适合高并发和频繁写操作；MyISAM 使用表级锁，适合读多写少的场景。
3.  **外键支持**：InnoDB 支持外键约束，保证数据的一致性和完整性；MyISAM 不支持外键。
4.  **全文索引**：MyISAM 原生支持全文索引，适合需要全文搜索的应用；InnoDB 从 MySQL 5.6 开始支持全文索引，但性能可能不如 MyISAM。
5.  **崩溃恢复**：InnoDB 支持自动崩溃恢复，通过重做日志和回滚日志实现快速恢复；MyISAM 只支持基于表的崩溃恢复，恢复过程较慢且不完全。
6.  **存储空间**：InnoDB 可能占用更多存储空间，但支持更大的表（最大表大小可达 64TB）；MyISAM 存储空间效率较高，数据文件较小，但受文件系统限制（单个表最大可达 256TB）。
7.  **读写性能**：InnoDB 在高并发和事务密集型场景下性能优越，写操作和并发处理能力强；MyISAM 在读多写少场景下性能优越，查询速度快，占用资源少。
8.  **数据备份和恢复**：InnoDB 支持热备份和在线备份，适合需要不间断服务的应用；MyISAM 备份和恢复相对简单，但需要停机操作，适合对服务连续性要求不高的应用。
9.  **其他存储引擎**：Memory 适合需要极高读写性能且数据不持久存储的场景；Archive 适合存储大量历史数据，支持高效的插入操作；NDB 适合需要高可用性和分布式存储的场景。



## MySQL的innodb和myisam索引的区别?

-   **聚簇索引**：
    -   InnoDB 使用聚簇索引，主键索引和行数据存储在一起，查询主键时效率高；
    -   MyISAM 使用非聚簇索引，索引和数据分开存储，主键索引只包含指向数据文件的指针。
-   **辅助索引**：
    -   InnoDB 的辅助索引存储索引列和主键值，通过主键找到实际数据；
    -   MyISAM 的辅助索引存储索引列和数据文件指针，直接通过指针找到实际数据。
-   **全文索引**：
    -   MyISAM 原生支持全文索引，适合需要全文搜索的应用；
    -   InnoDB 从 MySQL 5.6 开始支持全文索引，但在某些情况下性能可能不如 MyISAM。
-   **索引大小**：
    -   InnoDB 的索引由于包含行数据和事务日志，占用更多存储空间；
    -   MyISAM 的索引文件较小，存储空间利用率较高。
-   **索引锁定机制**：
    -   InnoDB 使用行级锁，允许更高的并发性和更细粒度的锁定；
    -   MyISAM 使用表级锁，索引操作时可能会锁定整个表，影响并发性能。
-   **数据一致性**：
    -   InnoDB 支持外键和事务，能够自动保证数据的一致性和完整性；
    -   MyISAM 不支持外键和事务，数据一致性需要通过应用层来处理。



## union和union all区别？

UNION和UNION ALL是 SQL 中用于合并两个或多个结果集的操作符。它们的主要区别在于是否去除重复的行。

-   **UNION**：去除重复行，需要额外的排序操作，性能较UNION ALL略低。
-   **UNION ALL**：保留所有行，不去重，性能较好。

**UNION**

-   **去除重复行**：UNION操作会自动去除合并结果中的重复行。
-   **排序操作**：由于UNION需要去除重复行，因此它会在内部执行一个排序操作来识别和删除重复行，这可能会影响性能。

```sql
SELECT column1, column2 FROM table1
UNION
SELECT column1, column2 FROM table2;
```

**UNION ALL**

-   **保留重复行**：UNION ALL操作不会去除重复行，所有的结果行都会被保留。
-   **性能较好**：由于UNION ALL不需要进行去重操作，因此通常比UNION性能更好，特别是在处理大数据量时。

```sql
SELECT column1, column2 FROM table1
UNION ALL
SELECT column1, column2 FROM table2;
```

假设有两个表table1和table2，它们的结构和数据如下：

```
-- table1
id | name
---|------
1  | Alice
2  | Bob

-- table2
id | name
---|------
2  | Bob
3  | Charlie
```

使用UNION：

```sql
SELECT id, name FROM table1
UNION
SELECT id, name FROM table2;
```

结果：

```
id | name
---|------
1  | Alice
2  | Bob
3  | Charlie
```

使用UNION ALL：

```sql
SELECT id, name FROM table1
UNION ALL
SELECT id, name FROM table2;
```

结果：

```
id | name
---|------
1  | Alice
2  | Bob
2  | Bob
3  | Charlie
```



## MySQL中数据排序的实现原理是什么？



## MySQL的索引类型有哪些？



## MySQL  InnoDB引擎中的聚簇索引和非聚簇索引有什么区别？



## MySQL中的回表是什么？



## MySQL索引最左前缀匹配原则？



## MySQL的覆盖索引？

## MySQL中建立索引需要注意什么？



## MySQL在使用索引一定有效吗？如何排查索引效果？





## MySQL中索引数量是否越多越好？为什么？



## 在什么情况下，不推荐为数据库建立索引？



## b树和b+树的理解？



## 简述MySQL的b+树查询数据的全过程？



## 为什么MySQL选择使用B+树作为索引结构？



## MySQL是如何实现事务的？



## MySQL中长事务可能会导致哪些问题？



## MySQL中MVCC是什么？





## 如果MySQL没有MVCC，会有什么影响？







## MySQL默认事务隔离级别是什么？为什么选这个级别？



## 脏读、不可重复读和幻读分别是什么？



## innoDB如何解决幻读？



## MySQL中有哪些锁类型？



## MySQL的乐观锁和悲观锁有什么区别？



## MySQL中如果发生死锁如何解决？





## 如何使用MySQL中的explain语句进行查询分析？





## MySQL中count(*)、count(1)和count(字段名)有什么区别？



## MySQL中int(11)的11表示什么？



## MySQL的varchar和char有什么区别？



## MySQL如何进行SQL调优？





## MySQL中如何避免单点故障？



## MySQL如何实现读写分离？Java代码中如何实现？







## MySQL的主从同步机制？它是如何实现的？



## 如何处理MySQL的主从同步延迟？



## 什么是分库分表？分库分表有哪些策略？如何实现？



## 如何在MySQL中实施分库分表策略？



## 对数据库实施分库分表可能会引发哪些问题？



## 从MySQL中获取数据，是从磁盘读取的吗？



## MySQL的Doublewriter Buffer是什么？有什么用？



## MySQL的Long Buffer是什么？有什么用？



## 为什么在MySQL在不推荐使用对表join？



阿里规范：



## MySQL在如何解决数据深度分页的问题？



## 如何在MySQL中监控和优化慢SQL？





## MySQL中delete、drop和truncate的区别？



## MySQL在inner join、left join、right join的区别是什么？



## MySQL中`limit 1000000,10`和`limit 10`的执行速度是否相同？



## MySQL中datetime和timestamp类型的区别？



## 数据库三大范式？



## 在MySQL中，你使用过哪些函数？常用函数？



## MySQL中text类型最大可以存储多长的文本？



## MySQL中auto_increment列到达最大值时会发生什么？



## 在MySQL存储金额数据，应该使用什么数据类型？



## 什么是视图？



## 什么是游标？



## 为什么不推荐在MySQL中直接存储图片、音频、视频等大容量内容？





## 相比Oracle，MySQL的优势有哪些？

## MySQL中varchar(100)和varchar(10)的区别？



## MySQL中exists和in的区别？



## 你是否在面试中被问过MySQL相关优化的问题呢？



## MySQL数据库的性能优化方法有哪些？



## MySQL的查询优化器如何选择执行计划？



## 什么是数据库逻辑删除？与物理删除有啥区别？



## 什么是数据库逻辑外键？和物理外键有啥区别？



## 如何实现数据库的不停服迁移？



## 你们生产环境的MySQL中使用了什么事务隔离级别？为什么？



## 为什么阿里手册不推荐使用存储过程？



## 什么是Write-Ahead-Logging（WAL）技术？它有啥优点？MySQL中是否用到了？



## MySQL的行级锁到底锁的是什么东西？





## 慢SQL优化思路？

1、SQL本身

-   **避免使用 select ***
    -   避免查询所有的字段。1、只查询我们需要的字段，减少数据传输量，提高IO性能
-   **避免子查询，使用JOIN替代**
    -   子查询都是嵌套查询，会创建临时表，增加性能损耗
-   **避免使用or查询，使用 union/union all 代替**
    -   mysql 5.0之前应该避免使用or查询，因为可能导致索引失效
    -   union可去重，union all不去重
-   **避免使用 != 或 < > 操作符，使用 in 代替**
    -   因为 != 或 < > 操作符等操作符导致查询引擎放弃使用索引来查找数据，转为变为全表查询
    -   注意，使用  != 时，字段上有索引也会走全表扫描，但是这个情况不是决定的
-   **避免使用 % 开头的 like 查询**
    -   会导致索引失效
-   **避免字段上使用函数**
    -   会导致索引失效

2、索引

-   **查询条件和连接条件的列上建立索引**
-   **利用覆盖索引**
    -   覆盖索引会减少回表查询
-   **适当使用前缀索引**
    -   比如说邮箱，后面几位是固定的，只需要针对前缀进行索引建立即可，减低索引的空间占用，提高索引查询效率
-   **正确使用联合索引，避免过多的列使用复合索引**
    -   因为如果联合索引中的字段过多的话，每当我们插入数据的时候都有可能会触发索引树的重构
-   **更新频繁的列慎用索引**
-   **避免范围查询数据量过多**，可能会导致索引失效
    -   因为在mysql中，是否走索引取决于执行计划的成本，这个成本是由mysql的优化器来进行选择的

3、其他

-   善用 **explain**
    -   分析sql执行计划，可以知道sql也没有使用到索引
-   **分页优化、排序优化、分组优化**
    -   确保排序、分组字段存在索引，并且能够成功利用索引
    -   深分页问题
-   **分解复杂查询**
    -   比如一个sql有1000行，通过物理手段来进行拆分（在代码中拆分），加速查询
-   **批量插入**
    -   每插入一条数据，提交事务非常浪费性能。比如可以优化为每500条数据提交一下事务
        -   需要进行压测，根据压测结果评测出一个性能最高的提交数量
-   **监控和分析工具**
    -   监控整个数据库或是哪一些地方出现了慢sql
-   硬件资源优化
    -   能够加机器解决的事都不是事