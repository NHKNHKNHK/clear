## MySQL事务的四大特性？

**口语化表述**

MySQL事务的四大特性就是ACID，分别是原子性、一致性、隔离性、持久性。其中原子性就是确保事务中的所有操作要么全部成功，要么全部失败；一致性是指数据库从一个一致性的状态转换到另外一个一致性的状态；隔离性确保并发执行的事务彼此隔离开来，避免相互干扰；持久性确保事务一旦提交，其结果是永久性的。

-   **1、原子性（Atomicity）**

定义：事务是一个不可分割的最小工作单元。原子性确保事务中的所有操作要么全部完成，要么全部不完成。

保证：如果事务在执行过程中遇到错误或中断，整个事务将被回滚（Rollback），以确保数据库状态不会部分更新。

例子：假设有一个银行转账操作，事务包括从账户A中扣钱和向账户B中加钱。如果任何一个操作失败，整个事务都会回滚，账户A和账户B的余额不会发生变化。

-   **2、一致性（Consistency）**

定义：一致性确保事务在完成后，数据库从一个一致状态转换到另一个一致状态。即事务开始前和结束后，数据库的完整性约束没有被破坏。

保证：事务执行过程中，任何中间状态对外部都是不可见的，只有当事务成功提交后，结果才会对其他事务可见

例子：在银行转账操作中，一致性确保转账后总金额保持不变。如果账户A减少了100元，账户B就应该增加100元。

-   **3、隔离性（Isolation）**

定义：隔离性确保并发执行的事务彼此隔离开来，避免相互干扰。不同的事务之间的操作是互不可见的，直到事务提交。

保证：通过不同的隔离级别（如读未提交、读已提交、可重复读、串行化）来控制并发事务之间的可见性和冲突。

**隔离级别**：

1.  **读未提交（Read Uncommitted）**：允许一个事务可以读到另一个未提交事务的数据，**可能导致脏读**。
2.  **读已提交（Read Committed）**：一个事务只能读到已提交事务的数据，避免脏读。
3.  **可重复读（Repeatable Read）**：一个事务在整个过程中看到的数据是一致的，避免不可重复读。
4.  **串行化（Serializable）**：最高隔离级别，事务完全串行化执行，完全避免了并发问题，但性能较低。

-   **4、持久性（Durability）**

定义：持久性确保事务一旦提交，其结果是永久性的，即使系统发生故障，数据也不会丢失。

保证：通过日志记录和定期备份等机制，确保事务提交后的数据能够持久保存。

例子：在银行转账操作中，一旦事务提交，转账操作的结果（账户A和账户B的余额变化）将永久保存在数据库中，即使之后系统崩溃，数据也不会丢失。



## MySQL的事务隔离级别？

MySQL 主要支持四种事务隔离级别，分别是读未提交、读已提交、可重复读和串行化。

简单来说，**读未提交**就是一个事务可以读取另一个未提交事务的数据，可能导致脏读，即一个事务读取了另一个事务未提交的数据。如果该事务回滚，那么读到的数据将是无效的。

**读已提交**是说一个事务只能读取已经提交的事务的数据。这样可以避免脏读，但可能会出现不可重复读，即A事务读取完数据后B事务提交数据，A事务再次读取的数据和上次不相同

**可重复读**是说一个事务在整个过程中多次读取同一行数据时，结果是相同的。可以避免脏读和不可重复读，但可能会出现幻读。

**串行化**，这种级别下，事务完全串行化执行，避免了脏读、不可重复读和幻读。代价是并发性大大降低，事务可能会因为锁等待而阻塞。



**读未提交（READ UNCOMMITTED）**

-   最低隔离级别：允许一个事务读取其他事务尚未提交的数据。
-   这种情况下可能会发生**脏读**（Dirty Reads），即一个事务可以读取到另一个事务中未提交的数据。
-   是四种隔离级别中并发性能最好的，但数据安全性最差。
-   使用场景：极少使用，因为可能会导致数据不一致的问题。

```mysql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

补充：

​	**脏读**：一个事务读取了另一个事务未提交的数据。如果该事务回滚，那么读到的数据将是无效的。

**读已提交（READ COMMITTED ）**

-   一个事务只能读取已经提交的数据。
-   避免了脏读的发生，但仍然可能出现**不可重复读**（Non-Repeatable Reads）和“幻读”（Phantom Reads）。
-   每次查询都会读取最新的已提交数据。
-   使用场景：适用于大多数应用程序，尤其是那些对数据一致性要求较高但可以容忍不可重复读的情况。

```mysql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

补充：

​	**不可重复读**：一个事务在读取同一行数据时，可能因为另一个事务的提交而得到不同的结果。

**可重复读（REPEATABLE READ ）**

-   MySQL **InnoDB 默认的隔离级别**。
-   在同一个事务中的多次查询返回相同的结果集，即使在这期间有其他事务对数据进行了修改并提交。
-   能够防止脏读和不可重复读，但仍然可能出现**幻读**（Phantom Read）。
-   InnoDB 存储引擎通过多版本并发控制（**MVCC**）来实现这一级别。
-   使用场景：适用于需要保证数据一致性的场景，例如银行系统、金融交易等。

```mysql 
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

补充：

​	**幻读**：一个事务在读取某个范围内的行时，另一个事务在该范围内插入了新的行（或删除了行），导致前一个事务再次读取时发现了“幻影”行

**串行化（SERIALIZABLE ）**

-   最高的隔离级别。
-   事务被强制按顺序执行，完全避免了并发操作带来的问题，如脏读、不可重复读和幻读。
-   但是，这种隔离级别可能会导致大量的锁定，从而降低了系统的并发性能。
-   使用场景：适用于对数据一致性要求极高的场景，例如在线拍卖系统、库存管理系统等。

```mysql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

设置 MySQL 事务隔离级别的示例：

```mysql
-- 设置全局事务隔离级别为可重复读 
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- 设置当前会话的事务隔离级别为读已提交 
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
-- 开始事务 
START TRANSACTION;
-- 在事务内进行操作 
SELECT * FROM accounts WHERE account_id ='A';
-- 提交事务 
COMMIT;

-- 查看当前会话事务隔离级别 
SELECT @@session.transaction_isolation;
-- 查看全局会话事务隔离级别 
SELECT @@global.transaction_isolation;
```

小结：

选择合适的事务隔离级别取决于你的应用程序的具体需求和性能考虑：

-   如果你需要最高的数据一致性，可以选择 SERIALIZABLE，但要注意其性能开销。
-   如果你希望在性能和一致性之间取得平衡，REPEATABLE READ 是一个不错的选择。
-   如果你能容忍不可重复读，READ COMMITTED 可能更合适。
-   避免使用 READ UNCOMMITTED，除非你明确知道其风险并愿意接受潜在的数据不一致性

​	选择合适的隔离级别需要权衡数据一致性和系统性能之间的关系。对于大多数应用，默认的可重复读隔离级别已经能够提供足够的数据一致性和并发性能。

| **隔离级别**                | **脏读** | **不可重复读** | **幻读** |
| --------------------------- | -------- | -------------- | -------- |
| Read uncommitted (读未提交) | 存在     | 存在           | 存在     |
| Read committed (读已提交)   | ×        | 存在           | 存在     |
| Repeatable read (可重复读)  | ×        | ×              | 存在     |
| Serializable (串行化)       | ×        | ×              | ×        |



## 什么是脏读、幻读、不可重复读？

**脏读**

定义：脏读是指一个事务能够读取到另一个事务修改的数据，且修改暂未提交。如果该未提交的事务后来回滚（rollback），那么第一个事务读取到的数据就是无效的或“脏”的。

例如：

​	张三的工资为5000，事务A中把他的工资改为8000，但事务A尚未提交。

​	与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。

​	随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。

​	最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。

**不可重复读**

定义：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。也就是说，**在同一个事务中，两次读取同一行数据得到的结果不同**。

例如：

​	在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。

​	与此同时，事务B把张三的工资改为8000，并提交了事务。

​	随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。

**幻读**

定义：幻读是指在一个事务内多次执行相同的查询时，由于其他事务插入或删除了数据行，导致查询结果集发生变化。具体来说，幻读表现为第一次查询时某些行不存在，而第二次查询时这些行出现了，或者相反。

例如：

​	目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。

​	此时，事务B插入一条工资也为5000的记录。

​	这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。



## 不可重复读和幻读有什么区别

不可重复读的重点是修改：同样的条件，你读取过的数据，再次读取出来发现值不一样了

幻读的重点在于新增或者删除：同样的条件，第 1 次和第 2 次读出来的记录数不一样。

| 特性     | 不可重复读（Non-Repeatable Read）          | 幻读（Phantom Read）                               |
| -------- | ------------------------------------------ | -------------------------------------------------- |
| 定义     | 同一行数据在同一个事务中多次读取结果不一致 | 相同查询在同一个事务中多次执行结果集不同           |
| 原因     | 其他事务修改了同一行数据                   | 其他事务插入或删除了符合条件的行                   |
| 解决方案 | 使用可重复读或序列化隔离级别               | 使用序列化隔离级别，某些数据库的可重复读也防止幻读 |
| 影响范围 | 单个行的数据变化                           | 查询结果集的变化（涉及多行）                       |



## MySQL的存储引擎有哪些？有什么区别？

**InnoDB**

-   **默认存储引擎**：自 MySQL **5.5** 版本起成为默认存储引擎。
-   **事务支持**：支持 ACID（原子性、一致性、隔离性、持久性）事务。
-   **行级锁**：提高并发性能，适合高并发读写操作。
-   **外键支持**：支持外键约束，确保数据完整性。
-   **崩溃恢复**：具有自动崩溃恢复功能。
-   **全文索引**：从 MySQL 5.6 开始支持全文索引。

**MyISAM**

-   非事务型存储引擎：**不支持事务**，但读取速度较快。
-   **表级锁**：在并发写入时性能较差，适合以读操作为主的场景。
    -   不支持行级锁
-   **全文索引**：支持全文索引，适合用于搜索引擎等应用。
-   **压缩表**：支持创建压缩只读表，节省磁盘空间。

补充：MySQL早期的默认存储引擎，项目开发中更多情况下被NoSQL取代

**MEMORY（HEAP）**

-   **内存表**：所有数据都存储在内存中，提供极高的读写速度。
-   **临时数据**：适用于需要快速访问的临时数据，如会话信息。
-   **表级锁**：使用表级锁，不适合高并发写入。
-   **非持久化**：重启后数据丢失，因此不适合持久化存储。

补充：项目开发中更多情况下被Redis取代

| 特点         | InnoDB           | MyISAM | Memory |
| ------------ | ---------------- | ------ | ------ |
| 存储限制     | 64TB             | 有     | 有     |
| 事务支持     | ✔                | x      | x      |
| 锁机制       | 表级锁、行级锁   | 表级锁 | 表级锁 |
| B+tree索引   | ✔                | ✔      | ✔      |
| Hash索引     |                  |        | ✔      |
| 全文索引     | ✔（5.6版本开始） | ✔      |        |
| 空间使用     | 高               | 低     | N/A    |
| 内存使用     | 高               | 低     | 中等   |
| 批量插入速度 | 低               | 高     | 高     |
| 外键支持     | ✔                |        |        |



除了InnoDB、MyISAM、Memory，还有如下存储引擎，了解即可

**ARCHIVE**

-   归档存储：主要用于存储大量历史数据，适合日志记录等场景。
-   压缩存储：数据被压缩存储，节省磁盘空间。
-   只读操作：仅支持插入

**CSV**

-   CSV 文件存储：将数据存储为 CSV 文件格式，便于与其他应用程序交换数据。
-   简单结构：适合简单的数据导入导出操作。
-   无索引：不支持索引，查询性能较低。
-   有限功能：功能有限，主要用于数据迁移或备份。

**BLACKHOLE**

-   **黑洞存储引擎**：所有插入的数据都被丢弃，类似于 **/dev/null**。
-   日志记录：可用于测试或调试，例如模拟 SQL 语句的日志记录。
-   无数据存储：不存储任何实际数据，查询总是返回空结果集。

**FEDERATED**

-   远程表访问：允许通过本地表访问远程 MySQL 数据库中的表。
-   分布式查询：适合分布式数据库环境，可以跨多个服务器进行查询。
-   性能开销：由于涉及网络通信，性能可能受到影响。

**NDB Cluster (NDB)**

-   集群存储引擎：用于 MySQL Cluster，提供高可用性和分布式处理能力。
-   分布式架构：数据分布在多个节点上，适合高可用性和容错需求。
-   实时应用：适用于需要低延迟和高可用性的实时应用。
-   复杂配置：配置和管理相对复杂，适合有经验的管理员。

**MERGE**

-   合并多个 MyISAM 表：将多个 MyISAM 表逻辑上合并为一个表，便于管理和查询。
-   统一视图：提供对多个表的统一视图，简化查询操作。
-   限制：只能合并 MyISAM 表，且不支持事务。

**PERFORMANCE_SCHEMA**

-   性能监控：用于收集和分析 MySQL 性能数据，帮助优化数据库性能。
-   内部使用：主要用于内部性能监控，不适合用户数据存储。



## MySQL中InnoDB和MyISAM的区别？

MyISAM和InnoDB都是mysql的存储引擎。

mysql5.5之前，默认的存储引擎是MyISAM，从5.5之后，默认的是InnoDB。

MyISAM 适用于**读多**写少的场景，如数据仓库、日志分析等；InnoDB 适用于事务密集型和高并发场景，如在线交易系统、社交网络等。

-   **事务支持**：
    -   MyISAM 不支持事务，无法进行回滚和提交操作；
    -   InnoDB 支持**事务**，提供 ACID 特性（原子性、一致性、隔离性、持久性）。

-   **锁机制**：
    -   MyISAM 使用**表级锁**，每次操作都会锁定整个表，适合读多写少的应用；
    -   InnoDB 使用**行级锁**，每次操作只锁定相关的行，适合高并发和写操作频繁的应用。

-   **外键支持**：
    -   MyISAM 不支持外键，无法在表间建立引用完整性约束；
    -   InnoDB **支持外键**，可以在表间建立引用完整性约束，保证数据的一致性和完整性。

-   **全文索引**：
    -   MyISAM 原生支持全文索引，适合需要全文搜索的应用；
    -   InnoDB 从 **MySQL 5.6 开始支持全文索引**，但性能和功能上仍不如 MyISAM。

-   **数据存储结构**：
    -   MyISAM 将数据存储在三个文件中（`.frm`文件存储表结构，`.MYD`文件存储数据，`.MYI`文件存储索引）；
    -   InnoDB 将**数据和索引**存储在表空间文件中，支持自动扩展和多表空间。（`.frm`文件存储表结构定义、`.idb`文件存储数据和索引）

-   **崩溃恢复**：
    -   MyISAM 只支持基于表的崩溃恢复，恢复过程较慢且不完全；
    -   InnoDB 支持**自动崩溃恢复**，通过重做日志和回滚日志实现快速和完整的恢复。

-   **性能特点**：
    -   MyISAM 在读多写少场景下性能优越，查询速度快，占用资源少；
    -   InnoDB 在高并发和事务密集型场景下性能优越，写操作和并发处理能力强。

-   **存储空间**：
    -   MyISAM 存储空间效率较高，数据文件较小；
    -   InnoDB 可能占用更多存储空间，特别是需要存储事务日志和外键约束信息。

-   **表的大小限制**：
    -   MyISAM 受文件系统限制，单个表最大可达 256TB（取决于文件系统）；
    -   InnoDB 最大表大小可达 **64TB**，适合处理大规模数据集。

-   **适用场景**：
    -   MyISAM 适用于读多写少的场景，如数据仓库、日志分析等；
    -   InnoDB 适用于事务密集型和高并发场景，如在线交易系统、社交网络等。



## 存储引擎应该如何选择？

三点主要原则：

​	1、 需要事务支持必选InnoDB，不需要事务选择MyISAM

​	2、如果表的大部分操作都是查询，数据不大，并发不大，可以考虑选择MyISAM，但是一般还是选择 innodb，有写又有读则选择InnoDB

​	3、如果系统奔溃导致数据难以恢复，且成本高，选择 innodb



选择 MySQL 的存储引擎时，应根据具体应用场景、性能需求、数据完整性要求等因素进行综合考虑。

1.  **事务支持**：InnoDB 支持事务和 ACID 特性，适合需要事务支持的应用；MyISAM 不支持事务，适合对数据完整性要求不高的应用。
2.  **锁机制**：InnoDB 使用**行级锁**，**适合高并发和频繁写操作**；MyISAM 使用表级锁，适合读多写少的场景。
3.  **外键支持**：InnoDB 支持外键约束，保证数据的一致性和完整性；MyISAM 不支持外键。
4.  **全文索引**：MyISAM 原生支持全文索引，适合需要全文搜索的应用；InnoDB 从 MySQL 5.6 开始支持全文索引，但性能可能不如 MyISAM。
5.  **崩溃恢复**：**InnoDB 支持自动崩溃恢复**，通过重做日志和回滚日志实现快速恢复；MyISAM 只支持基于表的崩溃恢复，恢复过程较慢且不完全。
6.  **存储空间**：InnoDB 可能占用更多存储空间，但支持更大的表（最大表大小可达 64TB）；MyISAM 存储空间效率较高，数据文件较小，但受文件系统限制（单个表最大可达 256TB）。
7.  **读写性能**：InnoDB 在高并发和事务密集型场景下性能优越，写操作和并发处理能力强；MyISAM 在读多写少场景下性能优越，查询速度快，占用资源少。
8.  **数据备份和恢复**：InnoDB 支持热备份和在线备份，适合需要不间断服务的应用；MyISAM 备份和恢复相对简单，但需要停机操作，适合对服务连续性要求不高的应用。
9.  **其他存储引擎**：Memory 适合需要极高读写性能且数据不持久存储的场景；Archive 适合存储大量历史数据，支持高效的插入操作；NDB 适合需要高可用性和分布式存储的场景。



## MySQL的innodb和myisam索引的区别?

-   **聚簇索引**：
    -   InnoDB 使用聚簇索引，主键索引和行数据存储在一起，查询主键时效率高；
    -   MyISAM 使用非聚簇索引，索引和数据分开存储，主键索引只包含指向数据文件的指针。
-   **辅助索引**：
    -   InnoDB 的辅助索引存储索引列和主键值，通过主键找到实际数据；
    -   MyISAM 的辅助索引存储索引列和数据文件指针，直接通过指针找到实际数据。
-   **全文索引**：
    -   MyISAM 原生支持全文索引，适合需要全文搜索的应用；
    -   InnoDB 从 MySQL 5.6 开始支持全文索引，但在某些情况下性能可能不如 MyISAM。
-   **索引大小**：
    -   InnoDB 的索引由于包含行数据和事务日志，占用更多存储空间；
    -   MyISAM 的索引文件较小，存储空间利用率较高。
-   **索引锁定机制**：
    -   InnoDB 使用行级锁，允许更高的并发性和更细粒度的锁定；
    -   MyISAM 使用表级锁，索引操作时可能会锁定整个表，影响并发性能。
-   **数据一致性**：
    -   InnoDB 支持外键和事务，能够自动保证数据的一致性和完整性；
    -   MyISAM 不支持外键和事务，数据一致性需要通过应用层来处理。



## union和union all区别？

UNION和UNION ALL是 SQL 中用于合并两个或多个结果集的操作符。它们的主要区别在于是否去除重复的行。

-   **UNION**：去除重复行，需要额外的排序操作，性能较UNION ALL略低。
-   **UNION ALL**：保留所有行，不去重，性能较好。

**UNION**

-   **去除重复行**：UNION操作会自动去除合并结果中的重复行。
-   **排序操作**：由于UNION需要去除重复行，因此它会在内部执行一个排序操作来识别和删除重复行，这可能会影响性能。

```sql
SELECT column1, column2 FROM table1
UNION
SELECT column1, column2 FROM table2;
```

**UNION ALL**

-   **保留重复行**：UNION ALL操作不会去除重复行，所有的结果行都会被保留。
-   **性能较好**：由于UNION ALL不需要进行去重操作，因此通常比UNION性能更好，特别是在处理大数据量时。

```sql
SELECT column1, column2 FROM table1
UNION ALL
SELECT column1, column2 FROM table2;
```

假设有两个表table1和table2，它们的结构和数据如下：

```
-- table1
id | name
---|------
1  | Alice
2  | Bob

-- table2
id | name
---|------
2  | Bob
3  | Charlie
```

使用UNION：

```sql
SELECT id, name FROM table1
UNION
SELECT id, name FROM table2;
```

结果：

```
id | name
---|------
1  | Alice
2  | Bob
3  | Charlie
```

使用UNION ALL：

```sql
SELECT id, name FROM table1
UNION ALL
SELECT id, name FROM table2;
```

结果：

```
id | name
---|------
1  | Alice
2  | Bob
2  | Bob
3  | Charlie
```



## MySQL中数据排序的实现原理是什么？



## 简述一条SQL在MySQL中的执行过程？



## MySQL的索引类型有哪些？



## MySQL  InnoDB引擎中的聚簇索引和非聚簇索引有什么区别？



## MySQL中的回表是什么？



## MySQL索引最左前缀匹配原则？



## MySQL的覆盖索引？

## MySQL中建立索引需要注意什么？



## MySQL在使用索引一定有效吗？如何排查索引效果？





## MySQL中索引数量是否越多越好？为什么？



## 在什么情况下，不推荐为数据库建立索引？



## b树和b+树的理解？



## 简述MySQL的b+树查询数据的全过程？



## 为什么MySQL选择使用B+树作为索引结构？



## MySQL是如何实现事务的？



## MySQL中长事务可能会导致哪些问题？



## MySQL中MVCC是什么？





## 如果MySQL没有MVCC，会有什么影响？







## MySQL默认事务隔离级别是什么？为什么选这个级别？



## 脏读、不可重复读和幻读分别是什么？



## innoDB如何解决幻读？



## MySQL中有哪些锁类型？



## MySQL的乐观锁和悲观锁有什么区别？



## MySQL中如果发生死锁如何解决？





## 如何使用MySQL中的explain语句进行查询分析？





## MySQL中count(*)、count(1)和count(字段名)有什么区别？



## MySQL中int(11)的11表示什么？



## MySQL的varchar和char有什么区别？



## MySQL如何进行SQL调优？





## MySQL中如何避免单点故障？



## MySQL如何实现读写分离？Java代码中如何实现？







## MySQL的主从同步机制？它是如何实现的？



## 如何处理MySQL的主从同步延迟？



## 什么是分库分表？分库分表有哪些策略？如何实现？



## 如何在MySQL中实施分库分表策略？



## 对数据库实施分库分表可能会引发哪些问题？



## 从MySQL中获取数据，是从磁盘读取的吗？



## MySQL的Doublewriter Buffer是什么？有什么用？



## MySQL的Long Buffer是什么？有什么用？



## 为什么在MySQL在不推荐使用对表join？



阿里规范：



## MySQL在如何解决数据深度分页的问题？



## 如何在MySQL中监控和优化慢SQL？





## MySQL中delete、drop和truncate的区别？



## MySQL在inner join、left join、right join的区别是什么？



## MySQL中`limit 1000000,10`和`limit 10`的执行速度是否相同？



## MySQL中datetime和timestamp类型的区别？



## 数据库三大范式？



## 在MySQL中，你使用过哪些函数？常用函数？



## MySQL中text类型最大可以存储多长的文本？



## MySQL中auto_increment列到达最大值时会发生什么？



## 在MySQL存储金额数据，应该使用什么数据类型？



## 什么是视图？



## 什么是游标？



## 为什么不推荐在MySQL中直接存储图片、音频、视频等大容量内容？





## 相比Oracle，MySQL的优势有哪些？

## MySQL中varchar(100)和varchar(10)的区别？



## MySQL中exists和in的区别？



## 你是否在面试中被问过MySQL相关优化的问题呢？



## MySQL数据库的性能优化方法有哪些？



## MySQL的查询优化器如何选择执行计划？



## 什么是数据库逻辑删除？与物理删除有啥区别？



## 什么是数据库逻辑外键？和物理外键有啥区别？



## 如何实现数据库的不停服迁移？



## 你们生产环境的MySQL中使用了什么事务隔离级别？为什么？



## 为什么阿里手册不推荐使用存储过程？



## 什么是Write-Ahead-Logging（WAL）技术？它有啥优点？MySQL中是否用到了？



## MySQL的行级锁到底锁的是什么东西？





## 慢SQL优化思路？

1、SQL本身

-   **避免使用 select ***
    -   避免查询所有的字段。1、只查询我们需要的字段，减少数据传输量，提高IO性能
-   **避免子查询，使用JOIN替代**
    -   子查询都是嵌套查询，会创建临时表，增加性能损耗
-   **避免使用or查询，使用 union/union all 代替**
    -   mysql 5.0之前应该避免使用or查询，因为可能导致索引失效
    -   union可去重，union all不去重
-   **避免使用 != 或 < > 操作符，使用 in 代替**
    -   因为 != 或 < > 操作符等操作符导致查询引擎放弃使用索引来查找数据，转为变为全表查询
    -   注意，使用  != 时，字段上有索引也会走全表扫描，但是这个情况不是决定的
-   **避免使用 % 开头的 like 查询**
    -   会导致索引失效
-   **避免字段上使用函数**
    -   会导致索引失效

2、索引

-   **查询条件和连接条件的列上建立索引**
-   **利用覆盖索引**
    -   覆盖索引会减少回表查询
-   **适当使用前缀索引**
    -   比如说邮箱，后面几位是固定的，只需要针对前缀进行索引建立即可，减低索引的空间占用，提高索引查询效率
-   **正确使用联合索引，避免过多的列使用复合索引**
    -   因为如果联合索引中的字段过多的话，每当我们插入数据的时候都有可能会触发索引树的重构
-   **更新频繁的列慎用索引**
-   **避免范围查询数据量过多**，可能会导致索引失效
    -   因为在mysql中，是否走索引取决于执行计划的成本，这个成本是由mysql的优化器来进行选择的

3、其他

-   善用 **explain**
    -   分析sql执行计划，可以知道sql也没有使用到索引
-   **分页优化、排序优化、分组优化**
    -   确保排序、分组字段存在索引，并且能够成功利用索引
    -   深分页问题
-   **分解复杂查询**
    -   比如一个sql有1000行，通过物理手段来进行拆分（在代码中拆分），加速查询
-   **批量插入**
    -   每插入一条数据，提交事务非常浪费性能。比如可以优化为每500条数据提交一下事务
        -   需要进行压测，根据压测结果评测出一个性能最高的提交数量
-   **监控和分析工具**
    -   监控整个数据库或是哪一些地方出现了慢sql
-   硬件资源优化
    -   能够加机器解决的事都不是事