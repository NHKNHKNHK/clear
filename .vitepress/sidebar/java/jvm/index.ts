export default [
  {
    text: 'JVM',
    items: [
      { text: '导航', link: '/03-JVM篇/' },
      { text: 'Java是如何实现跨平台的？', link: '/03-JVM篇/Java是如何实现跨平台的？' },
      { text: '说说对象的创建过程？', link: '/03-JVM篇/说说对象的创建过程？' },
      { text: '如何判断对象的存活？解释强引用、软引用、弱引用和虚引用？', link: '/03-JVM篇/如何判断对象的存活？解释强引用、软引用、弱引用和虚引用？' },
      { text: 'JVM的内存结构？', link: '/03-JVM篇/JVM的内存结构？' },
      { text: 'JVM的内存区域是如何划分的？', link: '/03-JVM篇/JVM的内存区域是如何划分的？' },
      { text: 'Java中的堆和栈的区别是什么？', link: '/03-JVM篇/Java中的堆和栈的区别是什么？' },
      { text: '堆里的分区怎么划分？', link: '/03-JVM篇/堆里的分区怎么划分？' },
      { text: '什么是Java中的直接内存？', link: '/03-JVM篇/什么是Java中的直接内存？' },
      { text: '编译执行和解释执行的区别是什么？JVM使用哪种方式？', link: '/03-JVM篇/编译执行和解释执行的区别是什么？JVM使用哪种方式？' },
      { text: '什么是Java中的常量池？', link: '/03-JVM篇/什么是Java中的常量池？' },
      { text: '什么是JVM垃圾回收的concurrent-mode-failure？产生它的真正原因是什么？', link: '/03-JVM篇/什么是JVM垃圾回收的concurrent-mode-failure？产生它的真正原因是什么？' },
      { text: 'JVM的TLAB是什么？', link: '/03-JVM篇/JVM的TLAB是什么？' },
      { text: '怎么分析OOM内存溢出？', link: '/03-JVM篇/怎么分析OOM内存溢出？' },
      { text: '你了解Java中的类加载器吗？', link: '/03-JVM篇/你了解Java中的类加载器吗？' },
      { text: '什么是Java中的JIT（Just-In-Time）？', link: '/03-JVM篇/什么是Java中的JIT（Just-In-Time）？' },
      { text: '什么是Java中的AOT（Ahead-Of-Time）？', link: '/03-JVM篇/什么是Java中的AOT（Ahead-Of-Time）？' },
      { text: '你了解Java中的逃逸分析吗？', link: '/03-JVM篇/你了解Java中的逃逸分析吗？' },
      { text: 'Java中常见的垃圾收集器有哪些？', link: '/03-JVM篇/Java中常见的垃圾收集器有哪些？' },
      { text: '什么是双亲委派？', link: '/03-JVM篇/什么是双亲委派？' },
      { text: '什么是指令重排？', link: '/03-JVM篇/什么是指令重排？' },
      { text: 'JVM怎么判断一个对象可以被回收？', link: '/03-JVM篇/JVM怎么判断一个对象可以被回收？' },
      { text: '如何判断对象是否是垃圾？不同垃圾回收方法的区别？', link: '/03-JVM篇/如何判断对象是否是垃圾？不同垃圾回收方法的区别？' },
      { text: '为什么Java的垃圾收集器将堆分为老年代和新生代？', link: '/03-JVM篇/为什么Java的垃圾收集器将堆分为老年代和新生代？' },
      { text: '为什么Java8移除了永久代（PermGen）并引入元空间（Metaspace）？', link: '/03-JVM篇/为什么Java8移除了永久代（PermGen）并引入元空间（Metaspace）？' },
      { text: 'G1垃圾收集的特点？为什么低延迟？', link: '/03-JVM篇/G1垃圾收集的特点？为什么低延迟？' },
      { text: 'G1垃圾回收流程？', link: '/03-JVM篇/G1垃圾回收流程？' },
      { text: 'CMS垃圾回收流程？', link: '/03-JVM篇/CMS垃圾回收流程？' },
      { text: '你了解Java的ZGC吗？', link: '/03-JVM篇/你了解Java的ZGC吗？' },
      { text: '为什么初始标记和重新标记需要STW（Stop-The-World）？', link: '/03-JVM篇/为什么初始标记和重新标记需要STW（Stop-The-World）？' },
      { text: '除了GC还有其他场景用安全点吗？', link: '/03-JVM篇/除了GC还有其他场景用安全点吗？' },
      { text: 'CMS的垃圾回收过程，为什么需要分四步？', link: '/03-JVM篇/CMS的垃圾回收过程，为什么需要分四步？' },
      { text: 'JVM垃圾回收调优的两个主要目标是什么？', link: '/03-JVM篇/JVM垃圾回收调优的两个主要目标是什么？' },
      { text: '如何对Java的垃圾回收进行调优？', link: '/03-JVM篇/如何对Java的垃圾回收进行调优？' },
      { text: '常用的JVM配置参数有哪些？', link: '/03-JVM篇/常用的JVM配置参数有哪些？' },
      { text: '如何在Java中进行内存泄露分析？', link: '/03-JVM篇/如何在Java中进行内存泄露分析？' },
      { text: '你常用哪些工具来分析JVM性能？', link: '/03-JVM篇/你常用哪些工具来分析JVM性能？' },
      { text: 'Java中的CMS垃圾收集器的写屏障如何维护卡表和增量更新？', link: '/03-JVM篇/Java中的CMS垃圾收集器的写屏障如何维护卡表和增量更新？' },
      { text: '什么是Java中的logging-write-barrier？', link: '/03-JVM篇/什么是Java中的logging-write-barrier？' },
      { text: '为什么G1垃圾收集器不维护年轻代到老年代的记忆集？', link: '/03-JVM篇/为什么G1垃圾收集器不维护年轻代到老年代的记忆集？' },
      { text: 'CMS和G1垃圾收集器如何维持并发的正确性？', link: '/03-JVM篇/CMS和G1垃圾收集器如何维持并发的正确性？' },
      { text: 'CMS和G1垃圾收集器在记忆集的维护上有什么不同？', link: '/03-JVM篇/CMS和G1垃圾收集器在记忆集的维护上有什么不同？' },
      { text: 'JVM新生代回收如何避免全堆扫描？', link: '/03-JVM篇/JVM新生代回收如何避免全堆扫描？' },
      { text: '为什么Java中某些新生代和老年代的垃圾收集器不能组合使用？比如ParNew和Parallel-Old', link: '/03-JVM篇/为什么Java中某些新生代和老年代的垃圾收集器不能组合使用？比如ParNew和Parallel-Old' },
      { text: '为什么Java中CMS垃圾收集器在发生Concurrent-Mode-Failure时的Full-GC是单线程的？', link: '/03-JVM篇/为什么Java中CMS垃圾收集器在发生Concurrent-Mode-Failure时的Full-GC是单线程的？' },
      { text: '什么是Java的PLAB？', link: '/03-JVM篇/什么是Java的PLAB？' },
      { text: '什么条件会触发Java的yong-GC?', link: '/03-JVM篇/什么条件会触发Java的yong-GC?' },
      { text: '什么条件会触发Java的Full-GC?', link: '/03-JVM篇/什么条件会触发Java的Full-GC?' },
      { text: 'Java中有哪些垃圾回收算法？', link: '/03-JVM篇/Java中有哪些垃圾回收算法？' },
      { text: '什么是三色标记算法？', link: '/03-JVM篇/什么是三色标记算法？' },
      { text: 'Java中yong-GC、old-GC、Full-GC、mixed-GC的区别？', link: '/03-JVM篇/Java中yong-GC、old-GC、Full-GC、mixed-GC的区别？' },
      { text: '为什么Java新生代被划分为S0、S1、Eden区？', link: '/03-JVM篇/为什么Java新生代被划分为S0、S1、Eden区？' },
    ]
  },
]