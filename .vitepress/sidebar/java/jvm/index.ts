const basePath = '/03-JVM篇/';
const learnPath = '03-JVM篇/learn/';

export default [
  {
    text: '《JVM简明教程》',
    collapsed: false,
    items: [
      { text: '什么是虚拟机', link: learnPath + '什么是虚拟机' },
      { text: 'JVM的整体结构', link: learnPath + 'JVM的整体结构' },
      { text: 'JVM的架构模型', link: learnPath + 'JVM的架构模型' },
      { text: 'JVM的架构模型', link: learnPath + 'JVM的架构模型' },
      { text: 'JVM的生命周期', link: learnPath + 'JVM的生命周期' },
      { text: 'JVM的发展历程', link: learnPath + 'JVM的发展历程' },
    ]
  },
  {
    text: 'JVM',
    collapsed: false,
    items: [
      { text: '导航', link: '/03-JVM篇/' },
      { text: 'Java是编译型还是解释型', link: basePath + 'Java是编译型还是解释型' },
      { text: 'Java是如何实现跨平台的？', link: basePath + 'Java是如何实现跨平台的？' },
      { text: '什么是AOT编译？和JIT有啥区别？', link: basePath + '什么是AOT编译？和JIT有啥区别？' },
      { text: 'Java是如何实现的平台无关', link: basePath + 'Java是如何实现的平台无关' },
      { text: '说说对象的创建过程？', link: basePath + '说说对象的创建过程？' },
      { text: '如何判断对象的存活？解释强引用、软引用、弱引用和虚引用？', link: basePath + '如何判断对象的存活？解释强引用、软引用、弱引用和虚引用？' },
      { text: 'JVM的内存结构？', link: basePath + 'JVM的内存结构？' },
      { text: 'JVM的内存区域是如何划分的？', link: basePath + 'JVM的内存区域是如何划分的？' },
      { text: 'Java中的堆和栈的区别是什么？', link: basePath + 'Java中的堆和栈的区别是什么？' },
      { text: '堆里的分区怎么划分？', link: basePath + '堆里的分区怎么划分？' },
      { text: '什么是Java中的直接内存？', link: basePath + '什么是Java中的直接内存？' },
      { text: '编译执行和解释执行的区别是什么？JVM使用哪种方式？', link: basePath + '编译执行和解释执行的区别是什么？JVM使用哪种方式？' },
      { text: '什么是Java中的常量池？', link: basePath + '什么是Java中的常量池？' },
      { text: '什么是JVM垃圾回收的concurrent-mode-failure？产生它的真正原因是什么？', link: basePath + '什么是JVM垃圾回收的concurrent-mode-failure？产生它的真正原因是什么？' },
      { text: 'JVM的TLAB是什么？', link: basePath + 'JVM的TLAB是什么？' },
      { text: '怎么分析OOM内存溢出？', link: basePath + '怎么分析OOM内存溢出？' },
      { text: '你了解Java中的类加载器吗？', link: basePath + '你了解Java中的类加载器吗？' },
      { text: '什么是Java中的JIT（Just-In-Time）？', link: basePath + '什么是Java中的JIT（Just-In-Time）？' },
      { text: '什么是Java中的AOT（Ahead-Of-Time）？', link: basePath + '什么是Java中的AOT（Ahead-Of-Time）？' },
      { text: '你了解Java中的逃逸分析吗？', link: basePath + '你了解Java中的逃逸分析吗？' },
      { text: 'JVM中有哪些垃圾回收算法', link: basePath + 'JVM中有哪些垃圾回收算法' },
      { text: 'Java中常见的垃圾收集器有哪些？', link: basePath + 'Java中常见的垃圾收集器有哪些？' },
      { text: '新生代和老年代的垃圾回收器有何区别', link: basePath + '新生代和老年代的垃圾回收器有何区别' },
      { text: '什么是双亲委派？', link: basePath + '什么是双亲委派？' },
      { text: '什么是指令重排？', link: basePath + '什么是指令重排？' },
      { text: 'JVM怎么判断一个对象可以被回收？', link: basePath + 'JVM怎么判断一个对象可以被回收？' },
      { text: '如何判断对象是否是垃圾？不同垃圾回收方法的区别？', link: basePath + '如何判断对象是否是垃圾？不同垃圾回收方法的区别？' },
      { text: '为什么Java的垃圾收集器将堆分为老年代和新生代？', link: basePath + '为什么Java的垃圾收集器将堆分为老年代和新生代？' },
      { text: '为什么Java8移除了永久代（PermGen）并引入元空间（Metaspace）？', link: basePath + '为什么Java8移除了永久代（PermGen）并引入元空间（Metaspace）？' },
      { text: 'G1垃圾收集的特点？为什么低延迟？', link: basePath + 'G1垃圾收集的特点？为什么低延迟？' },
      { text: 'G1垃圾回收流程？', link: basePath + 'G1垃圾回收流程？' },
      { text: 'CMS垃圾回收流程？', link: basePath + 'CMS垃圾回收流程？' },
      { text: '你了解Java的ZGC吗？', link: basePath + '你了解Java的ZGC吗？' },
      { text: '为什么初始标记和重新标记需要STW（Stop-The-World）？', link: basePath + '为什么初始标记和重新标记需要STW（Stop-The-World）？' },
      { text: '除了GC还有其他场景用安全点吗？', link: basePath + '除了GC还有其他场景用安全点吗？' },
      { text: 'CMS的垃圾回收过程，为什么需要分四步？', link: basePath + 'CMS的垃圾回收过程，为什么需要分四步？' },
      { text: 'JVM垃圾回收调优的两个主要目标是什么？', link: basePath + 'JVM垃圾回收调优的两个主要目标是什么？' },
      { text: '如何对Java的垃圾回收进行调优？', link: basePath + '如何对Java的垃圾回收进行调优？' },
      { text: '常用的JVM配置参数有哪些？', link: basePath + '常用的JVM配置参数有哪些？' },
      { text: '如何在Java中进行内存泄露分析？', link: basePath + '如何在Java中进行内存泄露分析？' },
      { text: '你常用哪些工具来分析JVM性能？', link: basePath + '你常用哪些工具来分析JVM性能？' },
      { text: 'Java中的CMS垃圾收集器的写屏障如何维护卡表和增量更新？', link: basePath + 'Java中的CMS垃圾收集器的写屏障如何维护卡表和增量更新？' },
      { text: '什么是Java中的logging-write-barrier？', link: basePath + '什么是Java中的logging-write-barrier？' },
      { text: '为什么G1垃圾收集器不维护年轻代到老年代的记忆集？', link: basePath + '为什么G1垃圾收集器不维护年轻代到老年代的记忆集？' },
      { text: 'CMS和G1垃圾收集器如何维持并发的正确性？', link: basePath + 'CMS和G1垃圾收集器如何维持并发的正确性？' },
      { text: 'CMS和G1垃圾收集器在记忆集的维护上有什么不同？', link: basePath + 'CMS和G1垃圾收集器在记忆集的维护上有什么不同？' },
      { text: 'JVM新生代回收如何避免全堆扫描？', link: basePath + 'JVM新生代回收如何避免全堆扫描？' },
      { text: '为什么Java中某些新生代和老年代的垃圾收集器不能组合使用？比如ParNew和Parallel-Old', link: basePath + '为什么Java中某些新生代和老年代的垃圾收集器不能组合使用？比如ParNew和Parallel-Old' },
      { text: '为什么Java中CMS垃圾收集器在发生Concurrent-Mode-Failure时的Full-GC是单线程的？', link: basePath + '为什么Java中CMS垃圾收集器在发生Concurrent-Mode-Failure时的Full-GC是单线程的？' },
      { text: '什么是Java的PLAB？', link: basePath + '什么是Java的PLAB？' },
      { text: '什么条件会触发Java的yong-GC?', link: basePath + '什么条件会触发Java的yong-GC?' },
      { text: '什么条件会触发Java的Full-GC?', link: basePath + '什么条件会触发Java的Full-GC?' },
      { text: 'Java中有哪些垃圾回收算法？', link: basePath + 'Java中有哪些垃圾回收算法？' },
      { text: '什么是三色标记算法？', link: basePath + '什么是三色标记算法？' },
      { text: 'Java中yong-GC、old-GC、Full-GC、mixed-GC的区别？', link: basePath + 'Java中yong-GC、old-GC、Full-GC、mixed-GC的区别？' },
      { text: '为什么Java新生代被划分为S0、S1、Eden区？', link: basePath + '为什么Java新生代被划分为S0、S1、Eden区？' },
    ]
  },
]