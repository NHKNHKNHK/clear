const basePath = '/02-Java集合篇/'

export default [
  {
    text: 'Java集合',
    collapsed: false,
    items: [
      { text: '导航', link: basePath + 'index' },
      { text: 'Java中有哪些集合类？概述Java集合体系？', link: basePath + 'Java中有哪些集合类？概述Java集合体系？' },
      { text: '数组和链表在Java中的区别？', link: basePath + '数组和链表在Java中的区别？' },
      { text: 'List、Set、Map之间的区别是什么？', link: basePath + 'List、Set、Map之间的区别是什么？' },
      { text: 'Collection和Collections的区别？', link: basePath + 'Collection和Collections的区别？' },
      { text: '为什么Map接口不继承Collection接口？', link: basePath + '为什么Map接口不继承Collection接口？' },
      { text: 'Arrays.asList() 方法把数组转换成集合', link: basePath + 'Arrays.asList() 方法把数组转换成集合' },
      { text: 'List和Array之间如何互相转换？', link: basePath + 'List和Array之间如何互相转换？' },
      { text: '集合遍历时remove或add操作注意事项？', link: basePath + '集合遍历时remove或add操作注意事项？' },
      { text: 'Comparable 和 Comparator的区别', link: basePath + 'Comparable和Comparator的区别' },
      { text: 'Iterable接口与Iterator接口的区别', link: basePath + 'Iterable接口与Iterator接口的区别' },
      { text: 'Enumeration和Iterator接口的区别', link: basePath + 'Enumeration和Iterator接口的区别' },
      { text: '为什么不把Iterable和Iterator合成一个使用', link: basePath + '为什么不把Iterable和Iterator合成一个使用' },
      { text: '什么是fail-fast机制（快速失败）？', link: basePath + '什么是fail-fast机制（快速失败）？' },
      { text: '什么是fail-safe机制（副本机制）？', link: basePath + '什么是fail-safe机制（副本机制）？' },
      { text: 'fail-fast和fail-safe有什么区别？', link: basePath + 'fail-fast和fail-safe有什么区别？' },
      { text: '如何确保函数不能修改集合？', link: basePath + '如何确保函数不能修改集合？' },
      { text: '哪些集合支持对元素的随机访问？', link: basePath + '哪些集合支持对元素的随机访问？' },
      { text: 'foreach于普通for循环的区别？', link: basePath + 'foreach于普通for循环的区别？' },
      { text: 'foreach和迭代器有什么关系？', link: basePath + 'foreach和迭代器有什么关系？' },
      { text: 'List遍历有那几种遍历方式？', link: basePath + 'List遍历有那几种遍历方式？' },
      { text: '什么是Java中的Copy-On-Write？', link: basePath + '什么是Java中的Copy-On-Write？' },
      { text: '常用的并发集合有哪些？', link: basePath + '常用的并发集合有哪些？' },
      { text: 'CopyOnWriteArrayList和Collections.synchronization有什么区别？分别有什么优缺点？', link: basePath + 'CopyOnWriteArrayList和Collections.synchronization有什么区别？分别有什么优缺点？' },
    ]
  },
  {
    text: 'List',
    collapsed: false,
    items: [
      { text: '请你介绍以下常见的List实现类', link: basePath + 'List/请你介绍以下常见的List实现类' },
      { text: 'ArrayList 与 Vector 的区别？', link: basePath + 'List/ArrayList 与 Vector 的区别？' },
      { text: 'ArrayList初始容量是多少？', link: basePath + 'List/ArrayList初始容量是多少？' },
      { text: 'ArrayList是如何扩容的？（扩容机制）', link: basePath + 'List/ArrayList是如何扩容的？' },
      { text: 'ArrayList第二次扩容时容量大小？', link: basePath + 'List/ArrayList第二次扩容时容量大小？' },
      { text: 'ArrayList的添加与删除元素为什么慢？', link: basePath + 'List/ArrayList的添加与删除元素为什么慢？' },
      { text: 'ArrayList是线程安全的吗？', link: basePath + 'List/ArrayList是线程安全的吗？' },
      { text: 'ArrayList如何保证线程安全？', link: basePath + 'List/ArrayList如何保证线程安全？' },
      { text: 'ArrayList可以插入null吗？为什么？', link: basePath + 'List/ArrayList可以插入null吗？为什么？' },
      { text: 'ArrayList和LinkedList有什么区别？', link: basePath + 'List/ArrayList和LinkedList有什么区别？' },
      { text: 'LinkedList 真的比 ArrayList 添加元素快吗？', link: basePath + 'List/LinkedList 真的比 ArrayList 添加元素快吗？' },
      { text: '栈和队列有什么区别？', link: basePath + 'List/栈和队列有什么区别？' },
      { text: '什么是阻塞队列？', link: basePath + 'List/什么是阻塞队列？' },
      { text: '如何手写一个生产者与消费者队列？', link: basePath + 'List/如何手写一个生产者与消费者队列？' },
      { text: '编程实现删除List集合中的元素，有几种方式？', link: basePath + 'List/编程实现删除List集合中的元素，有几种方式？' },
    ]
  },
  {
    text: 'Set',
    collapsed: false,
    items: [
      { text: 'Java中Set有哪些常见实现类？', link: basePath + 'Set/Java中Set有哪些常见实现类？' },
      { text: 'HashSet 中添加元素的过程？', link: basePath + 'Set/HashSet 中添加元素的过程？' },
      { text: 'HashSet如何实现线程安全？', link: basePath + 'Set/HashSet如何实现线程安全？' },
      { text: 'HashSet、LinkedHashSet、TreeSet的区别？', link: basePath + 'Set/HashSet、LinkedHashSet、TreeSet的区别？' },

      { text: 'HashSet和HashMap的区别是什么？', link: basePath + 'Set/HashSet和HashMap的区别是什么？' },
      { text: 'HashSet是如何保证元素唯一性的？', link: basePath + 'Set/HashSet是如何保证元素唯一性的？' },
      { text: '为什么HashSet的add方法是常量时间复杂度？', link: basePath + 'Set/为什么HashSet的add方法是常量时间复杂度？' },
    ]
  },
  {
    text: 'Map',
    collapsed: false,
    items: [
      { text: 'Java中Map有哪些常见实现类？', link: basePath + 'Map/Java中Map有那些常见实现类？' },
      { text: 'Hashtable 与 HashMap的区别？', link: basePath + 'Map/Hashtable 与 HashMap的区别？' },
      { text: 'HashMap和Hashtable的区别？', link: basePath + 'Map/Hashtable 与 HashMap的区别？' },
      { text: 'HashMap、LinkedHashMap、TreeMap与Hashtable的区别？', link: basePath + 'Map/HashMap、LinkedHashMap、TreeMap与Hashtable的区别？' },
      { text: '什么是IdentityHashMap？', link: basePath + 'Map/什么是IdentityHashMap？' },
      { text: '什么是WeakHashMap？', link: basePath + 'Map/什么是WeakHashMap？' },
      { text: 'HashMap是怎么计算hashCode的？（HashMap是怎么确定key存储在数组上的索引位置的？）', link: basePath + 'Map/HashMap是怎么计算hashCode的？（HashMap是怎么确定key存储在数组上的索引位置的？）' },
      { text: 'HashMap为什么要使用扰动函数？', link: basePath + 'Map/HashMap为什么要使用扰动函数？' },
      { text: '为什么HashMap扩容时采用2^n倍（2的幂次）？', link: basePath + 'Map/为什么HashMap扩容时采用2^n倍（2的幂次）？' },
      { text: 'HashMap的默认容器到底是多大？', link: basePath + 'Map/HashMap的默认容器到底是多大？' },
      { text: 'HashMap的主要参数都有哪些？', link: basePath + 'Map/HashMap的主要参数都有哪些？' },
      { text: '解决hash碰撞的方法？', link: basePath + 'Map/解决hash碰撞的方法？' },
      { text: '为什么HashMap的默认负载因子是0.75？', link: basePath + 'Map/为什么HashMap的默认负载因子是0.75？' },
      { text: '重新调整HashMap大小存在什么问题吗？', link: basePath + 'Map/重新调整HashMap大小存在什么问题吗？' },
      { text: 'HashMap扩容机制？', link: basePath + 'Map/HashMap扩容机制？' },
      { text: 'JDK1.7中HashMap的实现？', link: basePath + 'Map/JDK1.7中HashMap的实现？' },
      { text: 'JDK1.8中HashMap的实现？', link: basePath + 'Map/JDK1.8中HashMap的实现？' },
      { text: 'JDK8的HashMap的put过程？', link: basePath + 'Map/JDK8的HashMap的put过程？' },
      { text: '为什么String, Integer这样的wrapper类适合作为键？', link: basePath + 'Map/为什么String, Integer这样的wrapper类适合作为键？' },
      { text: '为什么JDK8对HashMap进行了红黑树改动？', link: basePath + 'Map/为什么JDK8对HashMap进行了红黑树改动？' },
      { text: 'JDK8对HashMap进行了哪些改动，除了红黑树？', link: basePath + 'Map/JDK8对HashMap进行了哪些改动，除了红黑树？' },
      { text: '为什么HashMap多线程会进入死循环？', link: basePath + 'Map/为什么HashMap多线程会进入死循环？' },
      { text: '使用HashMap时，有哪些提升性能的技巧？', link: basePath + 'Map/使用HashMap时，有哪些提升性能的技巧？' },
      { text: 'LinkedHashMap是如何保证有序性的？', link: basePath + 'Map/LinkedHashMap是如何保证有序性的？' },
      { text: 'LinkedHashMap为什么能用来做LRUCache？', link: basePath + 'Map/LinkedHashMap为什么能用来做LRUCache？' },
      { text: 'JDK7中ConcurrentHashMap的实现？', link: basePath + 'Map/JDK7中ConcurrentHashMap的实现？' },
      { text: 'JDK8中ConcurrentHashMap的实现？', link: basePath + 'Map/JDK8中ConcurrentHashMap的实现？' },
      { text: 'ConcurrentHashMap在JDK7和8之间的区别？', link: basePath + 'Map/ConcurrentHashMap在JDK7和8之间的区别？' },
      { text: 'ConcurrentHashMap的get方法是否需要加锁？', link: basePath + 'Map/ConcurrentHashMap的get方法是否需要加锁？' },
      { text: '为什么ConcurrentHashMap的k-v都不能为null？', link: basePath + 'Map/为什么ConcurrentHashMap的k-v都不能为null？' },
      { text: 'ConcurrentHashMap底层具体实现你知道吗？实现原理？', link: basePath + 'Map/ConcurrentHashMap底层具体实现你知道吗？实现原理？' },
      { text: '你遇到过ConrrentModificationException异常吗？', link: basePath + 'Map/你遇到过ConrrentModificationException异常吗？' },
    ]
  }
]