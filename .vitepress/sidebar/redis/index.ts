
const basePath = '/10-Redis/'

export default [
  {
    text: '《Redis简明教程》',
    collapsed: false,
    items: [
      { text: 'Redis简介与安装', link: basePath + 'learn/01-Redis简介与安装' },
      { text: 'Redis基础', link: basePath + 'learn/02-Redis基础' },
      { text: 'Redis五大常用数据类型', link: basePath + 'learn/03-Redis五大常用数据类型' },
      { text: 'Redis6中的新数据类型', link: basePath + 'learn/04-Redis6中的新数据类型' },
      { text: 'Redis中配置文件解读', link: basePath + 'learn/05-Redis中配置文件解读' },
      { text: 'Redis中的发布订阅', link: basePath + 'learn/06-Redis中的发布订阅' },
      { text: 'SpringBoot整合Redis', link: basePath + 'learn/07-SpringBoot整合Redis' },
      { text: 'Redis事务', link: basePath + 'learn/08-Redis事务' },
      { text: 'Redis中的持久化', link: basePath + 'learn/09-Redis中的持久化' },
    ]
  },
  {
    text: '基础',
    collapsed: false,
    items: [
      { text: 'Redis', link: basePath + '' },
      { text: '什么是Redis？', link: basePath + '什么是Redis？' },
      { text: 'Redis相比memcached有哪些优势？', link: basePath + 'Redis相比memcached有哪些优势？' },
      { text: 'Redis和memached的区别？', link: basePath + 'Redis和memached的区别？' },
      { text: 'Redis为什么那么快？', link: basePath + 'Redis为什么那么快？' },
      { text: 'Redis有哪些优点？', link: basePath + 'Redis有哪些优点？' },
      { text: 'Redis常见五大数据类型？', link: basePath + 'Redis常见五大数据类型？' },
      { text: 'Redis的高级数据类型有哪些？', link: basePath + 'Redis的高级数据类型有哪些？' },
      { text: 'Redis的一般使用场景？', link: basePath + 'Redis的一般使用场景？' },
      { text: 'Redis常用类型的应用场景？', link: basePath + 'Redis常用类型的应用场景？' },
      { text: 'Redis是单线程还是多线程？', link: basePath + 'Redis是单线程还是多线程？' },
      { text: 'Redis 为什么单线程还这么快？', link: basePath + 'Redis 为什么单线程还这么快？' },
      { text: 'Redis为什么要设计成单线程？6.0不是变成多线程了吗？', link: basePath + 'Redis为什么要设计成单线程？6.0不是变成多线程了吗？' },
      { text: 'Redis存在线程安全吗？为什么？', link: basePath + 'Redis存在线程安全吗？为什么？' },
      { text: 'Redis的list类型常见的命令？', link: basePath + 'Redis的list类型常见的命令？' },
      { text: 'Redis的Geo类型？', link: basePath + 'Redis的Geo类型？' },
      { text: 'Redis的Bitmap类型？', link: basePath + 'Redis的Bitmap类型？' },
      { text: 'Redis的HyperLogLog类型？', link: basePath + 'Redis的HyperLogLog类型？' },

      { text: 'Redis的setnx和setex的区别？', link: basePath + 'Redis的setnx和setex的区别？' },
      { text: 'Redis的内存淘汰策略？', link: basePath + 'Redis的内存淘汰策略？' },
      { text: 'Redis的过期策略？', link: basePath + 'Redis的过期策略？' },
      { text: 'redis key的过期时间和永久有效分别怎么设置？', link: basePath + 'redis key的过期时间和永久有效分别怎么设置？' },
      { text: '删除key的命令会阻塞redis吗？', link: basePath + '删除key的命令会阻塞redis吗？' },
      { text: 'Redis什么情况下会变慢？', link: basePath + 'Redis什么情况下会变慢？' },
      { text: 'redis常见性能问题和解决方案？', link: basePath + 'redis常见性能问题和解决方案？' },
      { text: 'redis回收进程如何工作的？', link: basePath + 'redis回收进程如何工作的？' },

    ]
  },
  {
    text: '持久化',
    collapsed: false,
    items: [
      { text: 'Redis的持久化机制？', link: basePath + 'Redis的持久化机制？' },
      { text: 'rdb的优势与劣势？', link: basePath + 'rdb的优势与劣势？' },
      { text: 'aof的优势和劣势？', link: basePath + 'aof的优势和劣势？' },
      { text: 'RDB和AOF的实现原理？以及优缺点？', link: basePath + 'RDB和AOF的实现原理？以及优缺点？' },
      { text: 'Redis生成rdb的时候，是如何处理正常请求的？', link: basePath + 'Redis生成rdb的时候，是如何处理正常请求的？' },
    ]
  },
  {
    text: '本地缓存',
    collapsed: false,
    items: [
      { text: '本地缓存与分布式缓存的区别？', link: basePath + '本地缓存与分布式缓存的区别？' },
      { text: '如何实现本地缓存？', link: basePath + 'local-cache/如何实现本地缓存？' },
      { text: 'Caffeine的缓存驱逐策略（过期策略）', link: basePath + 'Caffeine的缓存驱逐策略（过期策略）' },
    ],
  },
  {
    text: '分布式',
    collapsed: false,
    items: [
      { text: '怎么保证Redis的高并发高可用', link: basePath + '怎么保证Redis的高并发高可用' },
      { text: 'Redis的Cluster模式和Sentinel模式的区别是什么？', link: basePath + 'Redis的Cluster模式和Sentinel模式的区别是什么？' },
      { text: 'Redis主从有哪几种常见的拓扑结构？', link: basePath + 'Redis主从有哪几种常见的拓扑结构？' },
      { text: 'redis主从复制的核心原理？', link: basePath + 'redis主从复制的核心原理？' },
      { text: 'redis的同步机制是什么', link: basePath + 'redis的同步机制是什么' },
      { text: 'Redis的从服务器的作用？', link: basePath + 'Redis的从服务器的作用？' },
      { text: 'Redis的复制延迟有哪些可能的原因？', link: basePath + 'Redis的复制延迟有哪些可能的原因？' },
      { text: 'Redis集群脑裂？', link: basePath + 'Redis集群脑裂？' },
      { text: 'redis哨兵机制？', link: basePath + 'redis哨兵机制？' },
      { text: '部署三主三从redis集群', link: basePath + 'docs/docker中部署三主三从redis集群' },
    ]
  },
  {
    text: '场景',
    collapsed: true,
    items: [
      { text: '如果Redis扛不住了怎么办？', link: basePath + '如果Redis扛不住了怎么办？' },
      { text: '什么情况下会出现数据库和缓存不一致的问题？', link: basePath + '什么情况下会出现数据库和缓存不一致的问题？' },
      { text: 'Redis和MySQL如何保证数据一致性？', link: basePath + 'Redis和MySQL如何保证数据一致性？' },
      { text: '如何解决Redis和数据库的一致性问题？', link: basePath + '如何解决Redis和数据库的一致性问题？' },
      { text: '为什么需要延迟双删，两次删除的原因是什么？', link: basePath + '为什么需要延迟双删，两次删除的原因是什么？' },
      { text: '有了第二次删除，第一次还有意义吗？', link: basePath + '有了第二次删除，第一次还有意义吗？' },
      { text: '什么是缓存穿透？', link: basePath + '什么是缓存穿透？' },
      { text: '什么是缓存击穿？（热点key）', link: basePath + '什么是缓存击穿？（热点key）' },
      { text: '什么是缓存雪崩？', link: basePath + '什么是缓存雪崩？' },
      { text: '缓存击穿、雪崩、穿透的区别？', link: basePath + '缓存击穿、雪崩、穿透的区别？' },
      { text: '如果有大量的key需要设置同一时间过期，一般需要注意什么？', link: basePath + '如果有大量的key需要设置同一时间过期，一般需要注意什么？' },
      { text: 'Redis key过期了，为什么内存没释放？', link: basePath + 'Redis key过期了，为什么内存没释放？' },
      { text: 'redis的内存用完了会发生什么？', link: basePath + 'redis的内存用完了会发生什么？' },
      { text: 'Redis生成全局唯一ID', link: basePath + 'Redis生成全局唯一IDs' },
      { text: '什么是分布式锁？分布式锁的特点？', link: basePath + '什么是分布式锁？分布式锁的特点？' },
      { text: '如何实现分布式锁？', link: basePath + '如何实现分布式锁？' },
      { text: '为什么Redis实现分布式锁不合适？还是有很多公司在用？', link: basePath + '为什么Redis实现分布式锁不合适？还是有很多公司在用？' },
      { text: 'jedis与redisson对比有什么优缺点？', link: basePath + 'jedis与redisson对比有什么优缺点？' },
      { text: 'Redis实现分布式锁有什么问题吗？', link: basePath + 'Redis实现分布式锁有什么问题吗？' },
      { text: '看门狗机制的原理是什么？', link: basePath + '看门狗机制的原理是什么？' },
      { text: '分布式锁在未执行完逻辑之前就过期了怎么办？', link: basePath + '分布式锁在未执行完逻辑之前就过期了怎么办？' },
      { text: '看门狗一直续期，那客户端挂了怎么办？', link: basePath + '看门狗一直续期，那客户端挂了怎么办？' },
      { text: '看门狗解锁失败，会不会导致一直续期下去？', link: basePath + '看门狗解锁失败，会不会导致一直续期下去？' },
      { text: 'Redis的red lock？', link: basePath + 'Redis的red lock？' },
      { text: 'redlock的分布式锁是什么？', link: basePath + 'redlock的分布式锁是什么？' },
      { text: 'Redis如何实现延时队列', link: basePath + 'Redis如何实现延时队列' },
      { text: '如何基于Redisson实现一个延迟队列', link: basePath + '如何基于Redisson实现一个延迟队列' },
      { text: '什么是redis bigKey？如何解决？', link: basePath + '什么是redis bigKey？如何解决？' },
      { text: '如何解决热点key？', link: basePath + '如何解决热点key？' },
      { text: '如何快速实现一个布隆过滤器？', link: basePath + '如何快速实现一个布隆过滤器？' },
      { text: '如何快速实现一个排行榜？', link: basePath + '如何快速实现一个排行榜？' },
      { text: '如何用Redis统计海量UV？', link: basePath + '如何用Redis统计海量UV？' },
      { text: '如何使用Redis记录用户连续登录多少天？', link: basePath + '如何使用Redis记录用户连续登录多少天？' },
      { text: '什么情况下redis哨兵模式会产生数据丢失', link: basePath + '什么情况下redis哨兵模式会产生数据丢失' },

    ]
  },
  {
    text: '进阶',
    collapsed: true,
    items: [
      { text: 'RedisKeyValue设计原则有哪些？', link: basePath + 'RedisKeyValue设计原则有哪些？' },
      { text: '为什么EMBSTR的阈值是44？为什么以前是39？', link: basePath + '为什么EMBSTR的阈值是44？为什么以前是39？' },
      { text: 'Redis可以实现事务吗？', link: basePath + 'Redis可以实现事务吗？' },
      { text: 'Redis 事务三特性？', link: basePath + 'Redis 事务三特性？' },
      { text: 'Redis事务保证原子性吗，支持回滚吗？', link: basePath + 'Redis事务保证原子性吗，支持回滚吗？' },
      { text: 'Redis的事务和关系型数据库有何不同？', link: basePath + 'Redis的事务和关系型数据库有何不同？' },
      { text: 'Redis的lua脚本？', link: basePath + 'Redis的lua脚本？' },
      { text: 'Redis中如何实现队列和栈的功能？', link: basePath + 'Redis中如何实现队列和栈的功能？' },
      { text: '简述Redis的Ziplist和Quicklist？', link: basePath + '简述Redis的Ziplist和Quicklist？' },
      { text: '什么是Redis的ListPack？', link: basePath + '什么是Redis的ListPack？' },
      { text: 'Redis的内存碎片化是什么？如何解决？', link: basePath + 'Redis的内存碎片化是什么？如何解决？' },
      { text: 'Redis字符串的值最大能存多少？', link: basePath + 'Redis字符串的值最大能存多少？' },
      { text: 'Redis为什么不复用c语言的字符串？', link: basePath + 'Redis为什么不复用c语言的字符串？' },
      { text: '什么是Redis的ListPack？', link: basePath + '什么是Redis的ListPack？' },
      { text: '什么是Redis的ListPack？', link: basePath + '什么是Redis的ListPack？' },
      { text: 'Redis的发布订阅功能？', link: basePath + 'Redis的发布订阅功能？' },
      { text: '什么是redis哈希槽的概念？', link: basePath + '什么是redis哈希槽的概念？' },
      { text: '使用Redis集群时，通过key如何定位到对应节点？', link: basePath + '使用Redis集群时，通过key如何定位到对应节点？' },
      { text: '为什么Redis集群的最大槽数是16384个？', link: basePath + '为什么Redis集群的最大槽数是16384个？' },
      { text: 'Redis中的管道有什么用', link: basePath + 'Redis中的管道有什么用' },
      { text: 'Redis的pipeline？', link: basePath + 'Redis的pipeline？' },
      { text: '原生批处理命令(mset、mget)与Pipeline的区别？', link: basePath + '原生批处理命令(mset、mget)与Pipeline的区别？' },
      { text: '什么是Redis跳表？', link: basePath + '什么是Redis跳表？' },
    ]
  }
]