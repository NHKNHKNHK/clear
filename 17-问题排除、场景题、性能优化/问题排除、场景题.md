# 常识

## QPS、TPS、RT、吞吐量这些高并发性能指标？

**QPS (Queries Per Second)**:

-   指的是每秒钟系统能够处理的查询数量。
-   通常用来衡量服务器响应客户端请求的能力。
-   在Web应用中，这可以表示每秒内服务器成功处理了多少次HTTP请求。

**TPS (Transactions Per Second)**:

-   表示每秒钟系统能够处理的事务数量。
-   事务可以是一个完整的业务操作，例如一次数据库操作或一系列相关操作的组合。
-   对于某些系统来说，TPS和QPS可能是相同的，但在涉及多步骤操作的情况下，TPS可能会小于QPS。

**RT (Response Time)**:

-   响应时间指的是系统从接收请求到完成处理并返回响应所需的时间。
-   这个时间通常包括网络延迟、处理时间和可能的数据传输时间。
-   RT是衡量系统性能的一个重要指标，因为它直接影响用户体验。

**吞吐量**:

-   吞吐量通常指的是单位时间内系统能够处理的数据总量或请求总数。
-   它可以用来描述网络带宽、服务器处理能力等多种情况下的数据处理能力。
-   吞吐量有时可以与QPS或TPS等同使用，但更广泛地涵盖了系统整体的数据处理能力。



>   QPS = 并发数 / 平均响应时间



## 如何避免超预期的高并发压力压垮系统？


## CPU飙高系统反应慢怎么排查？



## 怎么分析JVM当前的内存占用情况？OOM后怎么分析？



## 你也没有排查过线上OOM的问题？如何排查？





## Spring Cloud Gateway 500问题排查？



## JDK序列化问题排查？



## 线上连接池爆满问题排查？



## Redis内存溢出了，你会怎么做？请说说排查思路和解决方案？



## 每次进入订单列表页面都会触发全量同步？



## 项目上有个导出excel场景发现很慢，怎么优化？



# 场景题

## 为什么POJO类布尔类型不要以is开头？

Java 开发中，POJO 类的布尔变量不应加 'is' 前缀，以免引起部分框架在序列化时的错误。由于部分框架（如：fastjson）依赖于JavaBean规范的get和set方法，不遵循规范可能导致访问问题。解决办法是使用属性名称直接作为方法名，以确保一致性。

>   阿里规约明确
>
>   ​	POJO中的任何布尔类型的变量不要加is前缀

例如

```java
@Data
public class Student implements Serializable {
    private String name;
    private boolan isMan;
}
```

如下使用，问题不大

```java
Student s = new Student();
s.setMan(true);
System.out.println(s.isMan()); // true	 注意这里是isMan，不是getMan
```

当使用fastjson进行序列化时

```java
Student s = new Student();
s.setMan(true);
System.out.println(JSON.toJSON(s)); // {"man":true}   注意这是的is前缀不见了
```

使用fastjson进行序列化时，发现布尔类型变量的`is`前缀不见了，因为根据JavaBean规范，isXxx会被认为是方法。而fastjson恰好遵循了JavaBean规范。

但我们使用其他序列化根据时，可以没有遵循JavaBean规范，例如：Gson

```java
Student s = new Student();
s.setMan(true);

Gson gson = new Gson();
System.out.println(gson.toJSON(s)); // {"isMan":true} 
```

演示一个错误的案例：

使用fastjson进行序列化，gson进行反序列化

```java
Student s = new Student();
s.setMan(true);

Gson gson = new Gson();
System.out.println(gson.fromJSON(JSON.toJSON(s), Student.class)); // Student(name=null, isMan=false)
```

因此，不建议在POJO类中使用is作为布尔类型的开头

**总结**

​	不同的序列化工具，对与布尔类型is的处理不同



## 为什么不推荐使用数据库自增主键？也不推荐使用UUID做主键？用雪花算法会存在哪些问题？

为什么不推荐使用数据库自增主键？以数据库id为例

如果单纯的基于表的自增id，如果说是单表业务，不会有多大问题，每条数据的id都能够唯一表示一行数据。当数量量大时，面临分库分表的时候，假设横向分了多个表，此时数据库表的自增id就无法无法确保数据的唯一性了。

当然你也可以使用**步长**去处理，假设分了3个表，一张表id自增是147，一张表id自增是258，一张表id自增是369，此时可以确保id的唯一性，但是当面临扩容的时候就会出现问题。例如，3张表变为4张表，此时工作量将是巨大的。

因此有了**分布式ID的解决方案**。比如是UUID，雪花算法。

但是**UUID也是不建议使用**的，这就要考虑InnoDB中索引的数据结构了

>   InnoDB默认是索引结构是B+树，它有一个概念就是：**索引即数据，数据即索引**。每张表默认都有一个主键索引树。主键索引树的叶子节点会完整的保存整行的数据，每个块就是一个page，默认16k。page页是内存跟磁盘交互的最小单位

第一它会**影响查询性能**，因为主键索引树中要存储大量的主键，而UUID比较长，占用的空间比较大，空间比较大，每行的数据也就越大，同样的数据量就需要更多的page页来承接，page页越多，索引树的高度也就越高，遍历的次数也就越多，遍历的page页也更多，表示与磁盘IO次数较多。第二就是**影响操作性能**，因为UUID是无序的、非趋势递增的，而主键索引树是需要排好序的，每次添加数据的时候都需要进行重排序（也叫树的分裂与合并），严重影响了操作数据的性能。所以开发中，应该尽量避免非趋势递增的主键id。

**雪花算法**它是由四部分组成的**64位**的二进制数据，然后转换为我们需要的十进制id。四部分分别是1bit符号位， 42bit的时间戳，10bit的机器id，12bit的序列号。时间戳、机器id、序列号三者确保了id的唯一性，也符合趋势递增。解决了UUID无需的问题，同时它又是一个64位的二进制，占用的空间小

但是他也存在一些问题：时间回拨问题、机器id管理问题、序列号一直（大部分）是0问题

**时间回拨问题**

因为雪花算法它生成id依赖于机器的时间戳，例如我们把系统的时间修改了，改成了过去的时间，就到导致id不是趋势递增的，甚至有可能出现id重复

**机器id管理问题**

在单台机器生成的时候没有问题，可以通过配置配置机器id，但是在集群部署时，假设有100台机器，那么要维护机器id是很难保证这个id不重复的，或者说很难维护，需要花费大量成本

**序列号一直（大部分）是0问题**

因为序列号的作用是在同一时间同一机器并发生成id时才会去递增，但是大部分场景下没有那么高的并发量，所以序列号一般就是0。

它存在什么问题呢？就是我们在取模，基于ID取模分库分表的场景，它可能会导致**数据的偏移**，因为0结尾取模一行一定会在偶数表内，这个时候可能很多的表是没有数据的。



**时间回拨问题解决思路**

-   直接抛出异常：牺牲可用性，当我们发现现在的时间戳比之前的id生成的时间戳还要小时，直接不在生成id，直接抛出异常
-   等待：当我们发现时间回拨问题时，直接等待时间恢复，并且设置一个最大的等待时间，如果超过等待时间直接抱错（这样子可以解决短时间内的时间回拨问题）
-   采用备用的方式：当我们发现时间回拨问题时，可以采用其他的机器id去生成，或者直接采用备用的一些方式去生成，比如说随机

**机器id管理问题解决思路**

-   配置文件：一般可以通过配置文件去配置，但是因为是人为操作，很难避免它是唯一的，并且也不好进行统一的管理
-   借助框架：比如说服务注册组件，服务注册他一定会有服务id，我们可以拿到注册中心的id。

**序列号一直（大部分）是0问题导致的分布分表数据不均匀解决思路**

-   解决思路是，当它是0的时候，去获取一个动态变化的值，比如说时间戳的最后一位，这样序列号会得到一个0或1的随机数



## 如何设计一个支持10W QPS的评论中台？你会怎么设计？



## 如何设计一个支持10W QPS的会员系统？



## 如何设计一个秒杀功能？



## 如何设计一个RPC框架？



## 如何设计一个消息队列？



## 如何设计一个线程池？



## 如何设计一个短链系统？



## 如何设计一个HashMap？



## 如何设计一个文件上传系统？



## 如何设计一个点赞系统？

## 如何设计一个敏感词过滤系统？

## 为什么复杂的架构一定要做分层设计？


## 单点登录（SSO）的设计与实现？




## 设计一个订单号的生成服务，该如何设计？



## 热点商家交易订单的写入如何处理？



## 外部机构的API交互如何防止外部机构服务不可用拖垮调用服务？



## 两个动作。下订单和扣钱，如何保证只能扣一次钱？



## 搜索引擎设计：信息搜索怎么避免大海捞针？



## 如何根据应用场景选中合适的消息中间件？



## Redis的双机房部署方案？



## 如果外部接口的RT无法保证，如何处理？



## 什么是限流？限流算法有哪些？怎么实现？



## 即时通信项目中，怎么实现历史消息的下拉分页加载？



## 让你实现一个订单超时取消，怎么设计？



## 让你实现一个分布式单例对象，怎么设计？



## 商家想要知道自己店铺最好的top50商品，如何实现？



## 朋友圈点赞功能实现？



## 抖音点赞功能实现？



## 分布式锁一般怎么实现？



## 如何设计一个分布式ID分号器？



## 如果让你统计每个接口每分钟调用的次数怎么统计？



## 线上消息队列故障，兜底改造方案？



## 一笔订单，在取消的那一刻用户刚好付款了，怎么办？



## 项目上发现出现很多重复订单，怎么处理？



## 线上发现Redis机器爆了，如何优化？



## 项目上需要导入一个几百万数据excel文件到数据库，有哪些注意点？



## 如果一笔订单，用户同时在微信和支付宝同时支付，会怎么样？



## 假设有一个1G大的HashMap，此时用户请求过来刚好触发它的扩容，会怎么样？怎么优化？



## 项目中如何设置远程调用的超时时间？



## 从网关再到各个微服务，如何设置RPC的超时时间。要考虑哪些问题？



## 如果没有内存限制，如何快速、安全地将1000亿条数据插入到HashMap中？



## 忘记密码后为什么是重置密码，而不是告知原密码？

因为服务端也无法得知原密码是啥

服务端在保存密码到数据库的时候，绝对不能直接铭文存储，铭文存储有以下风险:

-   数据库数据被盗风险
-   服务端相关人员恶意盗用等。。

通常我们将密码进行哈希加密，哈希算法是不可逆的，因此服务端也不知道我们的原密码是啥

常见的哈希算法：

-   MD5
-   SHA-256
-   Bcrypt

MD5，不同的密码加密后可能会产生相同的哈希值（即哈希冲突）

SHA-256，不同的密码加密后哈希冲突的可能性极低，比MD5抗碰撞性更强

MD5、SHA-256每次加密同一个密码都是固定的密文，可能存在暴力破解的风险，因此通常会采用SHA-256+盐的方式进行加密

>   盐：salt，即只要我们程序员才做到的字符串，可以有效的防止暴力破解

Bcrypt，自带盐，且每次加密盐都不一样，加密同一个密码可能得到的密文不一样，因此能够防止暴力破解



## 三次输错密码后，系统是这么做到不让我继续尝试的？





## 如何保证接口幂等性？



## 百万数据导出



## 10亿数据中如何实现URL去重？



# 经验

## Lombok使用技巧

开发中，如果想使用Lombok建造者模式来set属性，如下：

```java
@Data
@Builder	// @Data @Builder 与同时使用时，需要加上无参、满参注解
@AllArgsConstructor	
@NoArgsConstructor
public class OssReq {
    @ApiModelProperty(value = "文件存储路径")
    private String filePath;
    @ApiModelProperty(value = "文件名")
    private String fileName;
    @ApiModelProperty(value = "请求的uid")
    private Long uid;
    @ApiModelProperty(value = "自动生成地址")
    @Builder.Default	// 切记！！！
    private boolean autoPath = true;
}
```

