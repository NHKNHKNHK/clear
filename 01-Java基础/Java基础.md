# 常识

## i++与++i

i++ 与 ++i 的**区别**

-   i++：后置递增，先返回当前值，再自增
-   ++i：前置递增，先自增，再返回新值

**示例：**

```java
public static void main(String[] args){
    int i = 1;

    System.out.println("i: "  +   i);	// 1
    System.out.println("++i: "+   ++i); // 2
    System.out.println("i++: "+   i++); // 2
    System.out.println("i: "  +     i); // 3
    System.out.println("--i: "+   --i); // 2
    System.out.println("i--: "+   i--); // 2
    System.out.println("i: "  +   i);   // 1
}
```

## 服务可用性几个9的含义

服务可用性用“几个9”来表示是一种常见的衡量标准，用来描述系统在一定时间内的可靠性。每个“9”代表系统不可用时间的比例减少了一个数量级。下面是不同数量的“9”所代表的服务可用性水平：

|                                  | **通俗叫法** | **可用性级别** | **年度宕机时间** |
| -------------------------------- | ------------ | -------------- | ---------------- |
| **基本可用**                     | **2个9**     | **99%**        | **87.6小时**     |
| **较高可用**                     | **3个9**     | **99.9%**      | **8.8小时**      |
| **具有故障自动恢复能力的可用性** | 4个9         | 99.99%         | 53分钟           |
| **极高可用性**                   | 5个9         | 99.999%        | 5分钟            |
| **容错可用性**                   | 6个9         | 99.9999%       | 31秒             |

```
1年 = 365天 = 8760小时
99.9 = 8760*0.1%= 8760*0.001 = 8.76小时
99.99 = 8760*0.01%= 8760*0.0001 = 0.876小时 = 0.876*60 = 52.6分钟
99.999 = 8760*0.001%= 8760*0.00001 = 0.0876小时 = 0.0876*60 = 5.26分钟
```

-   较高可用：通常被认为是基本的商业级可用性标准
-   具有故障自动恢复能力的可用性：这通常被认为是较高的可用性标准，适用于大多数企业级应用
-   在设计高可用系统时，通常会采取多种措施来提高服务的可用性，如负载均衡、冗余架构、故障切换等

## JDK、JRE、JVM的关系？



## 为什么在编写Java代码会遇到乱码问题？



## Java中的I/O流是什么？



## 什么是Java中的网络编程？



## Java中的基本数据类型有那些？



## Java中有哪些访问修饰符？





# OOP

## 什么是Java的封装特性？





## Java中一个类可以继承多个类吗？



## Java为什么不支持多继承？



## Java中的序列化与反序列化？



## 什么是Java的迭代器？



## compare与



## String、StringBuffer和StringBuilder的区别？

-   **String**

不可变的字符序列；底层使用 char[]（JDK8之前），底层使用byte[]（JDK9及其之后）

-   **StringBuffer**

可变的字符序列；**JDK1.0声明，线程安全的，效率低；**

底层使用 char[]（JDK8之前），底层使用byte[]（JDK9及其之后）

-   **StringBuilder**

可变的字符序列；**JDK5.0声明，线程不安全的，效率高；**

底层使用 char[]（JDK8之前），底层使用byte[]（JDK9及其之后）

**源码启示**

-   如果开发中需要频繁的针对字符串进行增、删、改操作，建议使用StringBuilder或StringBuffer替换String，因为String效率低
-   如果开发中，不涉及线程安全问题，建议使用StringBuilder替换StringBuffer。因为使用StringBuilder效率高。
-   如果开发中，大体知道确定要操作的字符的个数，建议使用带int capacity 的构造器。可以避免因为底层频繁扩容导致的性能下降



## 怎么判断一个链条是不是环形链表？





## 什么是接口？



## 什么是抽象类？



## 接口和抽象类有什么区别？



## Java中的参数传递是按值还是按引用？



## 可变类与不可变类？



## 什么是Java中的不可变类？



## 简述Java中Exception异常体系？



## Java中的Exception和Error的区别？



## Java运行时异常和编译时异常的区别是什么？







## 方法重写与方法重载的区别？



## 什么是内部类？与普通的区别？有什么用？



## JDK8的新特性？



## Java中包装类与基础类型的区别？





## 什么是自动装箱和拆箱？





## 静态（类）变量和实例变量的区别？



## 静态（类）方法和实例方法的区别？



## hashCode和equal方法是什么？



## 重写 hashCode() 方法的基本原则？

-   在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。 
-   当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等。 
-   对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。

### 重写 equals()方法的基本原则？

-   重写 equals 方法的时候一般都需要同时复写 hashCode 方法。通常参与计算hashCode 的对象的属性也应该参与到 equals()中进行计算。 
-   推荐：开发中直接调用 Eclipse/IDEA 里的快捷键自动重写 equals()和 hashCode()方法即可。 

为什么用 Eclipse/IDEA 复写 hashCode 方法，有 31 这个数字？ 

首先，选择系数的时候要选择尽量大的系数。因为如果计算出来的 hash 地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突） 

其次，31 只占用 5bits,相乘造成数据溢出的概率较小。 

再次，31 可以 由 i*31== (i<<5)-1 来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率） 

最后，31 是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有 1 来整除！(减少冲突) 



## equal与==的区别？



## 为什么重写equals时也需要重写hashCode？



## for循环与foreach循环的区别？



## 为什么是动态代理？



## JDK动态代理与CGLib动态代理的区别？



## 什么是Java中的注解？



## 什么是反射？你是怎么用的？



## 什么是Java中的SPI（service provide interface）机制？



## 什么是泛型？泛型有什么用？



## 泛型擦除？



## Java中泛型的上下界限定符？



## Java中深拷贝和浅拷贝的区别？



## 什么是Java中的Integer缓存池？



## 简述Java的类加载过程？



## 什么是BigDecimal？何时使用？



## new String("abc")会创建几个对象？



## Java中final、finally、finalize的区别？



## 为什么JDK9中将String的char数组改为了byte数组?



## 一个线程在Java中被两次调用start()方法会发生什么？



## 栈和队列在Java中的区别？



## Java的Optional类是什么？有什么用？



## 



# 番外

## 如何在Java中调用外部可执行程序或系统命令？